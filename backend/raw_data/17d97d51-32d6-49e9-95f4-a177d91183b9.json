{
    "Title": "Pantry: A Macro Library for Python",
    "Authors": "Pang, Derek",
    "Year": "No year available",
    "Abstract": "Python lacks a simple way to create custom syntax and constructs that goes outside of its own syntax rules. A paradigm that allows for these possibilities to exist within languages is macros. Macros allow for a shorter set of syntax to expand into a longer set of instructions at compile-time. This gives the capability to evolve the language to fit personal needs.\nPantry, implements a hygienic text-substitution macro system for Python. Pantry achieves this through the introduction of an additional preparsing step that utilizes parsing and lexing of the source code. Pantry proposes a way to simply declare a pattern to be recognized, articulate instructions that replace the pattern, and replace the pattern in the source code. This form of meta-programming allows its users to be able to more concisely write their Python code and present the language in a more natural and intuitive manner.\nWe validate Pantry’s utility through use cases inspired by Python Enhancement Proposals (PEPs) and go through five of them. These are requests from the Python community for features to be implemented into Python. Pantry fulfills these desires through the composition of macros that that performs the new feature",
    "Keywords": "No keywords available",
    "Publisher": "SJSU ScholarWorks",
    "Publication Date": "No publication date available",
    "Journal": "No journal available",
    "Citation Count": 0,
    "Full Text": "San Jose State UniversitySJSU ScholarWorksMaster's Projects Master's Theses and Graduate ResearchFall 12-17-2018Pantry: A Macro Library for PythonDerek PangSan Jose State UniversityFollow this and additional works at: https://scholarworks.sjsu.edu/etd_projectsPart of the Programming Languages and Compilers Commons, and the Software EngineeringCommonsThis Master's Project is brought to you for free and open access by the Master's Theses and Graduate Research at SJSU ScholarWorks. It has beenaccepted for inclusion in Master's Projects by an authorized administrator of SJSU ScholarWorks. For more information, please contactscholarworks@sjsu.edu.Recommended CitationPang, Derek, \"Pantry: A Macro Library for Python\" (2018). Master's Projects. 657.DOI: https://doi.org/10.31979/etd.pydk-c57jhttps://scholarworks.sjsu.edu/etd_projects/657Pantry: A Macro Library for PythonA ProjectPresented toThe Faculty of the Department of Computer ScienceSan José State UniversityIn Partial Fulfillmentof the Requirements for the DegreeMaster of SciencebyDerek PangDecember 2018© 2018Derek PangALL RIGHTS RESERVEDThe Designated Project Committee Approves the Project TitledPantry: A Macro Library for PythonbyDerek PangAPPROVED FOR THE DEPARTMENT OF COMPUTER SCIENCESAN JOSÉ STATE UNIVERSITYDecember 2018Dr. Thomas Austin Department of Computer ScienceDr. Tim Disney Shape SecurityDr. Suneuy Kim Department of Computer ScienceABSTRACTPantry: A Macro Library for Pythonby Derek PangPython lacks a simple way to create custom syntax and constructs that goesoutside of its own syntax rules. A paradigm that allows for these possibilities to existwithin languages is macros. Macros allow for a shorter set of syntax to expand intoa longer set of instructions at compile-time. This gives the capability to evolve thelanguage to fit personal needs.Pantry, implements a hygienic text-substitution macro system for Python. Pantryachieves this through the introduction of an additional preparsing step that utilizesparsing and lexing of the source code. Pantry proposes a way to simply declare apattern to be recognized, articulate instructions that replace the pattern, and replacethe pattern in the source code. This form of meta-programming allows its users to beable to more concisely write their Python code and present the language in a morenatural and intuitive manner.We validate Pantry’s utility through use cases inspired by Python EnhancementProposals (PEPs) and go through five of them. These are requests from the Pythoncommunity for features to be implemented into Python. Pantry fulfills these desiresthrough the composition of macros that that performs the new feature.ACKNOWLEDGMENTSI want to Dr. Thomas Austin for his guidance and patience as this projectdeveloped.vTABLE OF CONTENTSSECTION1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52.1 Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52.1.1 Why Macros? . . . . . . . . . . . . . . . . . . . . . . . . . 62.1.2 Use of Macros . . . . . . . . . . . . . . . . . . . . . . . . . 72.1.3 Macro Hygiene . . . . . . . . . . . . . . . . . . . . . . . . 83 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113.1 C Preprocessor . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113.2 Lisp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143.3 MacroPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163.3.1 MacroPy, an implementation of Python macros usingAbstract Syntax Trees . . . . . . . . . . . . . . . . . . 163.3.2 Changing grammar for Literal String Interpolation . . . . . 184 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244.1 Pantry’s Structure . . . . . . . . . . . . . . . . . . . . . . . . . . 244.2 Declaring a Pantry Macro . . . . . . . . . . . . . . . . . . . . . . 254.3 Preprocessing Stages of Pantry . . . . . . . . . . . . . . . . . . . . 264.4 Pantry’s Hygiene Implementation . . . . . . . . . . . . . . . . . . 284.5 Pantry Context Methods . . . . . . . . . . . . . . . . . . . . . . . 295 Experimentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32vivii5.1 Style Standardization Macro . . . . . . . . . . . . . . . . . . . . . 325.2 Do-While Macro . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355.3 Coalesce Macro . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42LIST OF REFERENCES . . . . . . . . . . . . . . . . . . . . . . . . . . . 45LIST OF FIGURES1 A closer look at the preprocessing stage in the stages of C compilation 122 Taken from [1] a) shows undisciplined CPP usage b) showsequivalent disciplined CPP usage . . . . . . . . . . . . . . . . . . 133 Standard Python Stages in Interpretation . . . . . . . . . . . . . 244 Preprocessing Stages of Pantry . . . . . . . . . . . . . . . . . . . 26viiiSECTION 1IntroductionMacros are the specification on how a particular instruction is transformed intoanother, often longer, instruction. The programming language of Python does nothave built-in support for macros unlike many other languages such as C [2] or Racket[3].Programmers should be able to express a set of instructions more concisely andin a more intuitive manner than what is currently available in the Python language.To facilitate this, the ability to take commonly used patterns, clean them up, andcontain them in a macro is imperative. Macro-formed syntax allows code to lookshorter, cleaner, and more readable. In addition, macros allow for further features tobe developed and promotes the evolution of the Python language.1 x = 22 y = 33 print (x , y ) # output : 2 34 swap x y #swap macro s t a t e d here5 print (x , y ) #expec ted output :3 2Listing 1.1: Before Macro Expansion1 x = 22 y = 33 print (x , y ) # output : 2 34 tmp =x ; x =y ; y =tmp #Expansion5 print (x , y ) #output : 3 2Listing 1.2: After Macro ExpansionTake for instance listings 1.1 and 1.2. The goal is to create a simple macro, calledswap, that takes the next two variables and swaps their values. In Python, line 4 inlisting 1.1 would cause a syntax error since Python would not know what to do withthe swap keyword. As a macro, swap is able to expand right into the calling contextof where it is called. This allows variable reassignment to happen in the macro itself.If swap were a function, variable reassignment would not be able to occur within thefunction as the scope inside that function would be separate from the scope of whereit was called. With macros, the swap keyword along with the variables x and y would1be replaced with line 4 in listing 1.2, accomplishing the goal of swapping the twovalues through a custom syntax construction of our own creation.This project introduces Pantry, a library that implements a hygienic text-substitution macro expression system for the Python language. The library permitsPython programmers to detail how and what replaces a particular code pattern oftheir choice. Pantry uses parsing and lexing to introduce macros in a natural andeasy-to-use library. The library grants the capability for users to simply declare apattern to be recognized as a macro, articulate a set of instructions that will replacethat pattern, have the library go through the code to find and replace the establishedpatterns. With this library, the user will be able to reduce verbose syntax into simpler,more concise forms that will be more readable for the programmer.1 @star t toker . macro2 def swap ( ctx=ctx ) :3 x = ctx . next ( ) #Pantry pa t t e rn t r a v e r s a l f unc t i on4 y = ctx . next ( )5 aVar = ctx . c l ean ( ’ tmp ’ ) #Hygienize a dec l a r ed v a r i a b l e name6 return \"{2} = {0} ; {0} = {1} ; {1} = {2}\" . format (x , y , aVar )7 #Macro expansion temp la te re turned by macroListing 1.3: Swap Macro in PantryListing 1.3 shows how the simple swap macro used in listing 1.1 and 1.2 wouldbe written. The user just needs to follow the basic pattern of declaring a macro: havethe decorator @starttoker.macro as seen in line 1, have a basic function declarationwith the name of the function being the name the user wishes for the macro (in thiscase swap in line 2), have in the argument a Pantry context object imported from thePantry library, and finally have this macro function return the text template that willbe the expansion for the macro (line 6). The macro uses Pantry provided methods2to consume patterns from the scope of its location (lines 3-4) and uses the capturedpattern in its expansion (line 6).The creation of Pantry is influenced by a macro library in JavaScript calledSweet.js [4]. From this library we see an intuitive structure that allows the user todetermine the pattern to be replaced in the code and what should replace it. Pantryborrows inspiration from that structure to give its users a well-formed and intuitivesystem of generating macros for their programs with the ability of choosing what andhow the original instruction set is used in the macro.The contribution that Pantry gives to Python macros is to have a portablepotential to add new grammars to Python without having to dive into the Pythonsource code to edit the Python grammar. MacroPy [5], another macro library, isrestricted by Python’s grammar and must make its macro constructions fit Python’sexisting grammar. As Python files are interpreted completely before they are outputted,syntax errors (such as user defined keywords) that exist in a Python file cause acompilation error. Pantry allows for users to introduce new language features intothe existing Python language even if it breaks syntax. The Pantry macro library isdesigned to be utilized through conceptualizing the pattern in terms of tokens. Sodigesting the pattern of the macro would depend on consuming all of the patterntokens that would be part of the macro. The expansion of the macro is returned bythe macro in terms of strings or, that is to say, how the expansion would appear in thefile itself. This is opposed to thinking about how the macro and its expansion wouldbe in terms of tokens or nodes of the AST. This abstraction provides a streamlinedapproach in comparison to other possible implementations. MacroPy [5], (anotherlibrary that proposes macros for Python), leans more towards manipulation of thePython AST. This approach encounters some limitations which we discuss later inthis report.3This paper is divided into five main sections. Section 2 introduces various aspectsof macros; from what macros are used for, programming languages that have macrosas part of their design, and various stages and topics relating to macros that areimportant for the understanding of this project. Section 3 reviews related research onmacros. This section includes some Pantry predecessors like the C preprocessor andthe Lisp macro system and their contribution towards Pantry’s design. This sectionalso covers another Python macro system, MacroPy, and emphasizes the proficienciesand differences of Pantry in comparison. Section 4 is an in-depth walk-through ofPantry’s implementation, various aspects of the system, and discussion on designdecisions of the library. Section 5 demonstrates Pantry in action, along with a how-toon writing macros for personal use and various utilization of macros in practice. Thefinal section is a summary of the project, thoughts on future directions, and concludesthis paper.4SECTION 2BackgroundTo fully understand and utilize Pantry, a sound understanding of what macrosare and what they are used for will be beneficial to its user. Section 2 highlights someof the important concepts relating to macros.2.1 MacrosMacros fit into the broader programming paradigm known as metaprogramming.Metaprograms can be thought of as programs that manipulate programs. In otherwords, a program that works on a program using it as data to be analyzed ortransformed. While some forms of metaprogramming, like reflection, happen atrun-time, macros are a compile-time construct.Two forms of macros are important to consider. The first type is the text-substitution macro system that is usually associated with the C language. TheC preprocessor (CPP) takes a macro that a user defines and substitutes a macroexpansion wherever it encounters the macro. While this simplistic macro system canbring about the improvement of portability and readability of a program, due toworking on the flat level of lexical tokens, it causes many complicated and often subtleproblems. The simple text substitution method often overlooks its surrounding scopeleading to poor abstraction and unintended results. Poor abstraction, in this case,means that the macro and its pattern may make sense by itself but when expandedinto the location the macro is in the file, it turns to mean something different or notintended. Hygiene is also an issue of poor abstraction and occurs when variables inthe program and variables in the macro collide unintentionally. This is discussed inmore detail later in Section 2.1.3. A deeper look into the CPP can be found in Section3.1.The second type is the syntactic macro system and it is usually associated with5the Lisp language. In this system macros work on the level of the Abstract SyntaxTree (AST). Working on this level means that the expansion of a macro is a tree ofnodes that is spliced into the program’s AST, which is also a tree of nodes. This isunlike the text-substitution macros, which takes the text as lexical tokens or keeps itas text and replaces sections of the file in that manner. The benefit of working in theAST level is that structure is preserved, providing better abstraction and safety. Thismeans that its macros are better structured and are conscious of their position in thetree. As such, the macro expansion tends to have fewer invalid expansions and subtlebugs and errors. A closer look at syntactic macros and Lisp can be found in Section3.2.Pantry is a text-substitution macro system that leverages contextual informationto make macros aware of surrounding information. This curbs possible errors fromtraditional text-substitution macro systems despite working on the flat level of lexicaltokens. So while it does not form a tree, like a syntactical macro system, it is stillable to garner some of the features and safety that that system provides by recordingcontext cues.2.1.1 Why Macros?In a language like Lisp, macros are considered a core part of the language andprovide constructs that help evolve the language. However, in computer languageswith a more inclusive syntax and semantics, the built-in design of macros is not anessential as part of their design. As macros provide additional complexity and canproduce obscurity in analyzing code, languages designers can shy away from theimplementation of such a feature. A common question is then to ask why wouldthe use of macros be needed if some languages can do without it. This question isespecially significant in the terms of this project which introduces macros into Python,6a computer language that is designed without macros and which has a wealth ofsemantics and syntax available for the programmer.2.1.2 Use of MacrosMacros should be used when other existing programming language constructs donot fit the programmer’s needs. If a standard function can accomplish what is neededthere is no need to complicate the code with macros since doing so can increase thedifficulty of debugging as macros bring a level of dissociation to the code body. Twoareas in which macros excel are context creation and compile-time computation [6].Macros are often compared to functions as they do similar things. But while theymight look similar, they have significant differences in purpose that sets them apart.As Paul Graham [7] explains it:A function produces results, but a macro produces expressions—which,when evaluated, produce results.In regard to context creation, macros retain the lexical context of where the macro islocated. In contrast, functions provide a new lexical context and hence lose access tothe original scope. Macros can expand into the calling context [7]. An example of thisdifference would be the earlier example of the swap macro in listing 1.3. A functionhas to have a variable passed as one of it parameters to use its value. Since Pythonis call-by value, reassigning a variable in a function does not change the variable inthe calling context. With macros however, since the macro expansion occurs withthe lexical context, the variable will be reassigned leading to the increased amount offlexibility that macros can have over other standard language constructs.Python has a rich set of language features. Even so, it sometimes does not containthe particular structure that is desired. For this reason, macros are particularlyeffective in providing a means to generate a Domain Specific Language (DSL). Macroscan aid in creating grammar constructs that are needed for a specific use or domain.7Other times, while the language does contain a particular feature, the syntax might bequite verbose or complicated. Macros can alleviate this by simplifying or compactingboilerplate code to provide a better abstraction. Since macros are expanded beforerun-time, they have the ability to directly access the source code itself. Additionally,computation can be done at compile-time. If the macro is given the value of anargument (i.e. the number 3 instead of a variable set to 3) at the macro expansionstage, the computation can be done at compile-time lending this concept the name,compile-time computation [7]. This allows for repeated computation that is donewhenever a program is ran to be separated and done only once at compile-time instead.Racket even has primitives that only work at compile-time to help facilitate suchcompile-time computations [8].Macros change the source code and they provide a further level of abstraction.Proper use of this abstraction can improve the program and programming style butimproper use further obfuscates and complicates, making the code harder to read andmaintain.2.1.3 Macro HygieneInadvertent variable capture is when the macro uses a variable name that isalready in use from the original scope it was called from. This is an issue that macrosmust take into account. Free symbol capture and macro argument capture are twotypes of inadvertent variable capture [7]. Macro argument capture is when the patternthat is fed into the macro contains a variable name that is also used within the macrofunction. An example of this is seen in 2.2 where a variable consumed by the swapmacro has the same name as a variable generated by the expansion leading to anincorrect result. Free symbol capture is when the macro function uses a variable thatis already used in the code, reassigning that variable value. This can lead to errors as8the output of that particular variable could be unexpected or incorrect as seen in 2.1.For a macro system to be a true syntactic abstraction, its users should not need toconsider the small details of the macro implementation as they use the macro withintheir program. This means that variables created and used within the macro shouldnot unintentionally refer to another variable of the same name. Use of the same namemight lead to unintended results if the macro expansion encounters a name clashin the scope of the expansion. As mentioned earlier, macros keep the same lexicalcontext where they are located.1 tmp = 0 #Ear l i e r v a r i a b l e ’ tmp ’2 x = 23 y = 34 print ( x y )5 tmp =x ; x =y ; y =tmp #Expansion6 print (tmp) #Expected 07 #Free Symbol Capture causes 2Listing 2.1: Free Symbol Capture1 tmp = 22 y = 33 print (tmp y)4 #Macro expansion error fromMacro Argument Capture5 tmp =tmp ; tmp =y ; y =tmp6 #Swap macro w i l l not swap va l u e sListing 2.2: Macro Argument CaptureMacros are affected by their lexical context and affect it as well. A variabledeclared earlier in the original scope will be the same variable declared within themacro and its value will have an influence on the macro result. In the same vein, achange to a variable used within the macro will likewise extend to the rest of theoriginal scope. Consider listing 1.1 and 1.2. If earlier in the code there existed avariable tmp = 0 and after the swap macro is called tmp will no longer be equal to0 but to 2. If this variable is called later in that program the programmer will beexpecting that the variable to be set to 0 but the macro would change that. This is atype of problem called hygiene that macro systems needs to take into account andattempt to avoid.9Hygiene can be achieved in several ways. One way is to use variable names thatare unlikely to be used. For example instead of using the variable x, x is insteadrenamed to xmacrovariable01. This solution, while the simplest, is not foolproof asthere is an off chance that a variable name could be used no matter how it is named.The only certain way to have hygienic macros is to make sure that the variablevulnerable to inadvertent capture, has a unique name in the macro. To ensure itsunique name, a list of variable names is gathered and any macro variable with thesame name that wants to be hygienic would be changed to have a unique variation ofthat name.10SECTION 3Related Work3.1 C PreprocessorThe C preprocessor (CPP) is is a tool that is built into the C language. It is nota direct part of compilation step but instead occurs right before it, transforming theprogram with text substitutions of any macros that have been defined. Preprocessorsin general are not necessarily the same language as the file that they are working on;in fact, CPP has its own grammar separate but related to the C language. Macros inCPP are defined using keywords used by CPP. The keywords in CPP usually startwith a # symbol followed by a directive. Some commands include:• #define• #include• #if• #endif• #ifdef• #ifndefWith these statements and more, the CPP can manipulate the program to replacetext, have conditional awareness, as well import header files from other libraries intothe program. There are also a few predefined definitions in the CPP such as __DATE__,__TIME__, or defined.The CPP belongs to the text substitution macro system type. A distinguishingcharacteristic of these systems is the preprocessing stage. This macro system is alsocalled the lexical macro system because it works on the level of lexical tokens in thepreprocessing step. These systems do not take into account syntactic structure whenexpanding macros in the program.As seen in Figure 1 the standard preprocessing step breaks down the file into11Figure 1: A closer look at the preprocessing stage in the stages of C compilationtokens and handles the substitutions at that step before it is handed to the compiler.There are two forms of CPP preprocessing: the traditional CPP and the standard CPP.The main difference between the two approaches is that traditional preprocessing doesnot change the input into tokens but treats it as a text stream. This preprocessingstep is further broken down into more detail, which can be found in [2].There are many pitfalls that can be encountered when using the CPP, so the useof CPP requires careful considerations and following of conventions in order to avoidthese issues [2]. One well-known pitfall is the Operator Precedence Problem wherethe macro could group its arguments in an unintended way, leading to an incorrectoutput. This problem can be prevented by liberal use of parentheses to enclose themacro and the arguments that the macro uses in its definition.As the CPP does not take the syntactic structure into account, it becomes easyfor developers to use the CPP directives in an undisciplined manner [1]. An example ofthis can be seen in Figure 2. Undisciplined use of CPP brings about more complexity,making code harder to understand, maintain, and create tools for.Although the CPP is rife with problems if not used carefully, it surprisingly isstill used quite often. Ernst et al. [9] analyses several packages and find that 48%of the CPP directives are conditional directives (the ifdef and other if variations),12Figure 2: Taken from [1] a) shows undisciplined CPP usage b) shows equivalentdisciplined CPP usage32% were the define directive, and 15% were the include directive, though the mixof directives varied greatly between different packages. Despite widespread agreementthat use of the CPP makes bugs easier to introduce into the program and harder tofind [10], the flexibility that the CPP brings is hard to ignore. In the same paper, theauthors asked developers using the CPP what alternatives they would use to replaceCPP and they generally gave three types of answers:• Guideline utilization when using CPP to prevent problems• In-language mechanisms usage when possible in place of CPP• Reasons as to why the CPP cannot be replaced133.2 LispLisp is one of the earlier high-level programming languages and is now a group oflanguages. The main derivatives of Lisp are Scheme and Common Lisp. Lisp’s namecomes from \"List processor\" due to the fact that its original source code is made up oflists and the list is one of its main data structures. When compiled, a Lisp programwill become a list [7]. One of Lisp’s most prominent characteristic is that it has anS-expression syntax. S-expression syntax is defined from the way that the languageis made up of nested lists. This means that an element of a list can also be a listand from this an organization of elements can be made into a tree structure. In thisform the program is also the program’s data. Lisp can easily manipulate and evaluatethese lists easing the implementation of macros in the language. The S-expressionsin Lisp are also delimited by parentheses, further simplifying how macros work inthe language as it eases the ability to parse the structure of the program. Racket,a language that started off as a Lisp derivative and later branched off into its ownentity, also shares the S-expression syntax.Another aspect of Lisp is its syntactic macro system. Unlike with CPP, a syntacticmacro system uses the same language and grammar as the programming languagewhere the macro is used. It has the language available as it is working on the macroexpansion. Syntactic macro systems, like the one in Lisp, works on the level of theabstract syntax tree and performs transformations on it to expand the macro. Thispreserves lexical structure and allows macros to be less error prone.The Lisp family of languages is especially suited to the creation of domain specificlanguages (DSL) due in part to its macro system. The ability to create new constructsallows for the creation of constructs especially suited for a particular domain, as canbe seen in bioinformatic projects like Pathway Tools or BioBike [11] or big data [12].Lisp is often called \"the programmable programming language\" due to this flexibility14[13].An example of how useful this flexibility can be in other languages can be seenin a Python keyword, with. The with keyword was implemented into the Pythonlanguage in Python 2.5 [14]. An example of with in use would be in opening andclosing a file. In programming it is important to close a file after you have opened afile and have finished with performing operations on it to release the allocated memory.Before with, Python programmers would have to explicitly have a close commandto tear down and release the resource. This necessity of having to explicitly havea close command is tedious and opens the door to error if the programmer forgetsto release the allocated memory. The with statement does it automatically withoutrequiring an explicit close statement. Programmers in Python had to wait for thePython developers to implement with into the language.Lisp programmers would be able to implement this syntax into the languagethemselves with the use of macros, and not have to wait for the language developersto get around to it.153.3 MacroPyAs macros are not part of the Python standard library, the Python communityhas toyed around with possible macro implementations. MacroPy is a project writtenby Haoyi et al. [5]. This section introduces MacroPy and compares it with Pantry.3.3.1 MacroPy, an implementation of Python macros using Abstract Syn-tax TreesMacroPy implements Python syntactic macros. To write macros in MacroPythere are a few requirements to make the macros created valid and usable. Oneof the requirements and a restraint of MacroPy is that it cannot use the samemacros in the file that is being run directly. This library requires that themacros be passed through import hooks, and as such, a certain convention mustbe followed for the library to be utilized correctly. MacroPy’s documentationrecommends creating three files when writing code that uses MacroPy macros.1 import macropy . a c t i v a t e2 import t a r g e tListing 3.1: MacroPy’s example bootstrapper fileThe first file is a simple bootstrapper file that includes an import to the file that hascode that the user wants to run (line 2) along with an activation import (line 1) thatsets up the MacroPy library as can be seen in listing 3.1. The second file is the filecontains code with the macro/s being used. An example of this can be seen in listing3.2. In the case of listing 3.1 the file would be named target.py. This file must includethe import statement \"from macro_module import macros, ...\" so that MacroPyknows what macros will be used. In this statement, \"macro_module\" is the third filewhere the user defines their macros and what they expand to. An example of this fileis seen in listing 3.3.It is important to have \"macros\" come first in this statement before naming16the macros that will come from that file. Otherwise, the macro will be importedincorrectly and an error will be returned. The \"...\" will be replaced by the functionnames of the macros that have been defined in the macro_module file. The third filethat has the defined macros must contain an instance of the Macros() class frommacropy.core.macros. This is used to define what type of macros is being definedsince a Macros() class contains methods for several different types of macros.The macros that the user defines are functions that access the abstract syntax tree(AST) and perform operations on the AST whenever the macro is called. The macrois given an AST object on which they can then perform the desired operations ortransformations. After the transformation, the macro then returns the new AST objectwhich replaces the previous AST tree at the location of the macro. As the target filethat has the __main__ module is being walked through, the AST is modified whereverit encounters a macro. The AST is compiled after the file has been completely walkedthrough.There are three types of macros available in MacroPy: expression, block, anddecorator macros. Each of these macros is denoted through a decorator function totell MacroPy what type of macro is being defined. Expression macros use squarebrackets to hold the AST object being modified. Block macros are macros that areused with the Python with keyword. Decorator macros are macros that are used asdecorators represented in Python with the @ symbol.To make the macros hygenic, MacroPy provides a gen_sym() function whichgenerates a name that has not been used in the code. When it is called it walksthrough the code and finds all names that have been used. Then it generates a namethat does not match its collection of found names. The MacroPy library includesdemos of macros that have come implemented with the library to demonstrate thecreation of macros in MacroPy. These macros also showcase the various applications17that are possible with the ability to intercept Python at the level of its abstract syntaxtree.3.3.2 Changing grammar for Literal String InterpolationThis section goes through and compares how macros are written in MacroPy andhow an equivalent macro would be written in Pantry. The following macro will beusing a Python Enhancement Proposal (PEP) as specifications to the macro beingcreated as well as the inspiration as to why it would be created.PEPs are a formatted form of documentation for new Python features that thePython community wishes to see added to or changed in Python. PEPs are gatheredtogether in an index where they accumulate community feedback and input. Theycan be rejected, accepted, or amended. PEPs are a wonderful source of inspiration forpossible macros for this project because they can contain features that the Pythoncommunity wants to see implemented in Python. As these are features that arewanted by parts of the Python community it is a wonderful way to test the validityof introducing Pantry to Python.The inspiration for this macro is PEP 536, which requests the lifting of somegrammar restrictions on Literal String Interpolation [15]. This macro will take some ofthe PEP’s suggestions and implement it into the Python language. This PEP concernsthe limitation of grammar of f-string literal string interpolation. In Python there areseveral ways to do string interpolation including %-formatting, String.format(),and f-strings. F-string is a newer form of literal string interpolation introduced inPEP 498. PEP 536 suggests changing the grammar restrictions on f-strings to allowfor a more intuitive design. Some of these changes include the allowance of the use of’\\’ characters within the f-string or to allow for the use of the same type of quote thatis used to quote the f-string.181 from macro_module import macros , f s t r i n g2 bag = {}3 bag [ ’wand ’ ] = ’ works ’4 print ( f s t r i n g [ ’Magic wand { bag [ \\ ’wand \\ ’ ] } ’ ] )Listing 3.2: MacroPy’s PEP 536 target.py fileListing 3.2 shows one of the three needed files when using macros in MacroPy.This is the file where the macro is being used and is waited to be expanded by MacroPy.In this case the macro \"fstring\" is enclosed by square brackets to let MacroPy knowwhat will be included in the macro and replaced. Macros enclosed by square bracketsare called expression macros in MacroPy and the code contained in the square bracketsis the snippet that will be given to the AST transformer and given to the macrofunction.191 import as t2 from macropy . core . macros import Macros3 macros = Macros ( )45 @macros . expr #Signa l s e xpre s s i on macro6 def f s t r i n g ( t ree , ∗∗kw) :78 i f isinstance ( t ree , a s t . Str ) :9 sForm = ast . l i t e r a l_ e v a l ( t r e e )10 l i s t o fV a r s = [ ]11 openVar = sForm . f i nd ( ’ { ’ ) + 112 c loseVar = −113 nStr ing = \"\"14 while openVar > 0 :15 . . .16 . . .17 nTree = ast . parse ( nStr ing ) . body [ 0 ] . va lue #Changes to a s t form1819 else :20 print ( ’ I n c o r r e c t Macro content ’ )2122 return nTreeListing 3.3: MacroPy’s PEP 536 partial fstring_macro.pyThis is the actual macro that will replace the fstring snippet that was seen inlisting 3.2. With MacroPy the macro must be in a separate file from where it willbe used in order to work properly. The Macros() class on line 3 must be definedin order to properly signal what type of macro will be used. The type of macro issignified in the Python decorator as seen in line 5, in this case it is an expression20macro. The different types of macros are all denoted by the @macro.type formatwhere the type can be of the three types of macros mentioned earlier: expr, block,decorator. MacroPy takes the code in an Abstract Syntax Tree form (AST). Thisparticular macro was written to takes the AST form and converts it into a string forease of manipulation. The transformation to a string form is found in line 9. Sinceit is changed into a string it is important that it is transformed back to an ASTform before it is returned so in line 17 it is converted back into the AST format thatcooperates with MacroPy.211 import s t a r t t ok e r , os2 from s t a r t t o k e r import ctx as ctx34 @star t toker . macro #Signa l s a macro5 def f s t r i n g ( ctx=ctx ) :6 i n f o r = ctx . next ( )78 l i s t o fV a r s = [ ]9 openVar = i n f o r . f i nd ( ’ { ’ ) + 110 c loseVar = −111 nStr ing = \"\"12 while openVar > 0 :13 . . .14 . . .15 return ’ \" ’ + nStr ing + ’ \" ’ + ’ . format ( ’ + \" , \" . j o i n ( l i s t o fV a r s ) + ’ ) ’#Returns a t e x t stream ins t ead o f AST1617 bag= {}18 bag [ ’ t e s t ’ ] = ’ works ’19 print ( f s t r i n g ’Magic wand1 : {bag [ \\ ’ t e s t \\ ’ ] } ’ )Listing 3.4: Pantry’s PEP 536 partial macroPantry’s macros do not require separate files to function, as can be seen in listing3.4, the macro (lines 4-15) and the code that the macro will be expanded in (lines17-19) are in the same file. Pantry also looks at the macro and the code snippet asa string so the additional conversions to and from the AST are not necessary. Asan advantage of not having to look at the code in an AST form, the writer of themacro is free to write it in a form that can break the Python syntax. In line 19 themacro does not have to be enclosed by brackets but is more free formed and thus22more closely fits with the specification of PEP 536. MacroPy would not be able to dothis because it would be stopped by a Python syntax error preventing it from startingthe macro expansion to access the AST. An in-depth look into the implementationand what is needed in writing a Pantry macro can be found in Section 4.MacroPy has to abide by Python grammar rules. It works on the level of theAST and still requires for the entire file to be interpreted before it is compiled. Pantryhowever introduces an additional step to the interpretation process. The additionalstep allows for the bypassing of Python grammar in the initiation of the macro. Byallowing macros to be unrestricted by Python grammar rules, the macro is able toconsider and accept a custom grammar that fits what the author of the grammarwants.23SECTION 4ImplementationSection 4 is an in-depth walk-through of Pantry’s implementation. We also reviewdesign decisions of the library.4.1 Pantry’s StructureAn important issue that Pantry desired to solve was to create ways to introduceor make available new grammars and/or syntactic structures to Python. This in-cludes new grammars concepts like the with statement introduced in Python 2.5 andmentioned in Section 3.2.Figure 3: Standard Python Stages in InterpretationIn Python, the entire file is compiled into byte code before anything is executed.This characteristic means that syntax errors in a program stop it from even getting tothe stage where the file can be executed. To bypass this limitation, Pantry introducesan additional stage in the preprocessing stage before a Python file is compiled. In thispreprocessing stage it finds any defined macros and removes them from the code beingcompiled into byte code. This allows the Python program to bypass syntax errorscaused by the new grammars defined by macros. At this stage, Pantry can start toparse and generate the AST of the file without worry of a returned syntax error fromthe macros that break Python’s standard grammar rules.The removed macros are then broken down into Python tokens using a Pythonstandard library, tokenize. A standard library is a library that is included with thePython language and requires an import statement but does not require a separatedownload of a library. This library utilizes Python’s grammar to break down the input24into lexical tokens recognized by Python. Pantry is a macro system that wishes to takea text-substitution/preprocessing macro system and cross it with a syntactic macrosystem. Text-substitution macro systems are prone to result in unexpected macroexpansions because it is not aware of the syntactic structure in its expansion site,while syntactic macros are aware and thus are less prone to such problems. Pantryutilizes a preprocessing stage to perform text substitution macro expansion but hasmechanisms in place to garner some of the benefits of syntactic macros. Pantry keepsnotes of the syntax structure of where the macro was located allowing expansion tobe regulated by the library and reduce improper expansions that result in malformedprograms. Furthermore, macros in Pantry are written in Python, enabling Pythonprogrammers to learn Pantry more readily and use Python to do work in the macrofunction.The Context class is a very important class of Pantry. Syntactic macros utilizetoken trees to preserve lexical structure and enable hygienic macros [16]. Pantry,however, uses this class to get a general idea of the lexical structure and how themacro should be expanded. This class keeps track of various information about themacros and the inputted file. Some examples of what is being kept tracked of includeswhat variables have been used, the location of where in the file the preprocessing stageis currently at, or where macros are located and how to correctly identify them. Thisclass also contains the mechanisms to correctly consume the lexical tokens that themacros envelope to aid the user in extracting from the code the correct arguments tobe utilized in or make up the macro expansion.4.2 Declaring a Pantry MacroPantry macros are functions with a specifically marked decorator denoting itsstatus as a Pantry macro.@starttoker.macro25The decorator is located in Pantry’s starttoker file and tells Pantry that the functiondecorated with this notation is a macro. The name of the function is recorded andthis recorded name is what Pantry scans through the file for to replace with a macroexpansion.4.3 Preprocessing Stages of PantryFigure 4: Preprocessing Stages of PantryTo expand macros Pantry goes through three main preprocessing stages. Pantry’sfirst stage is to identify and extract macro functions being used within the file. AsPantry allows for syntax breaking in macro names, the unsafe macro names mustbe recognized and extracted so that the macro definition can be compiled. Pantryextracts any unsafe macro names and replaces it with a Python-syntax-safe substitute.The macro name and this substitute are linked together so calling the substitute willtrigger that particular unsafe macro.The second stage is the marking of macros within the file. In order to bypassPython syntax errors identified macros are isolated from the compilation of the file.Their location is noted by Pantry. During this stage used variables within that fileare also noted and their names are stored to facilitate hygienic macros.The third stage is the macro expansion stage. In this stage Pantry goes throughthe file and starts replacing and expanding the macros that it has located throughoutthe file. Pantry tokenizes the entire file into Python lexical tokens through the use ofthe tokenize module.26Token Token Number Token Name’x’ 1 NAME’:’ 53 OP’ ’ 5 INDENT’’ 6 DEDENTThis is a small sample and example of tokens that the tokenize module generates.Tokens generated are tuples of five values. The general structure of which is as follows:TokenInfo(type, string, start, end, line)The type of the token is the type of token that it is. It is represented by a number ofwhich is unique to that particular token. The string of the token is the text value ofthe token. The start and end value is the location of starting and ending positionof the token. Their values are tuples with the length of two, each element of whichcontains an integer value. The first number of the tuple is the row that the token islocated in. The second number is the column that it is located in. The line value isthe entire line of tokens that is fed into the tokenize module. It marches throughthe file until it reaches a match for a macro. The macro is then expanded accordingto the rules and patterns that was listed in the macro function. Any tokens that wereutilized within the macro pattern is considered part of the macro and also removed.The macro returns a text stream that goes into the location that the macro is locatedin. The macro function returns in terms of concrete syntax, or the syntax that thelanguage is written in, as opposed to the abstract syntax of the AST. Concrete syntaxmeans that the syntax is the same the language where the expansion happens at. Useof concrete syntax as opposed to abstract syntax promotes understandability andreduction of complexity as well as other benefits in use cases where abstracting thesyntax in order to manipulate a program is undesirable [17]. The concrete syntaxof the returned text stream is checked for hygiene using a list of variables that iscontained within the Context class.274.4 Pantry’s Hygiene ImplementationIn order to make Pantry a hygienic macro system, that is to have the the variablebindings be hygienic at the expansion site, the library has adopted the gen_sym()method found in [7]. It does this through a clean method that makes sure that thevariable name being used does not clash within the file. Pantry does not supportdefinition-site hygiene, where the variables are renamed automatically in the macroexpansion template but instead renames the variable when it is declared within themacro instructions. If the expansion template explicitly states a variable name tobe returned, that variable name will be kept unhygienic but if that variable name isdeclared and stored in a variable and then used in the return expansion template, itwill be hygienic. While renaming variables to make sure they do not have a nameclash with other variables is not the only method to achieve hygienic macros, as [18]uses sets of scopes to do so, Pantry decided that the the gen_sym() method wouldbetter fit its library. Pantry automatically goes through the program that the macrostakes place in and collects all the variables used in the program. The collection ofvariables are gathered in the prepocessing stage of Pantry after the macros have beendetected and marked. From the list of used variable names, Pantry adjusts the namesof any variables created in the macro so that macros are self-contained and users willnot have to worry about accidental variable capture. Any new variables created andreturned by the macro will have an addition to their name to make them unique.Variables that require the use of variables already existing in the scope where themacro is called will retain their name. Variable names are made unique through acomparison of a list of taken variable names and the addition of a suffix at the end ofthe variable name. The addition of the suffix is only applied if the searched variablename is already in use and thus on the list. The suffix contains a number that iscontinuously incremented until there is no matching variable name.281 tmp = 0 #Ex i s t i n g l o c a l v a r i a b l e2 tmp__0 = 03 x = 24 y = 35 print (x , y )6 swap x y7 print (x , y )Listing 4.1: Before Hygienic MacroExpansion1 tmp = 02 tmp__0 = 03 x = 24 y = 35 print (x , y )6 tmp__1 =x ; x =y ; y =tmp__17 print (x , y )Listing 4.2: After Hygienic MacroExpansionRecall from Section 1 where the swap macro expansion has a new variable, tmp,in the expansion. If the file has a variable named tmp earlier in the file, the macroexpansion should hygienize that variable name. Using the same macro shown in listing1.3, listing 4.2 shows that if the macro is hygienic then it returns a variable name thatwill not clash with earlier variable names.4.5 Pantry Context MethodsPantry automatically adds a list of used variable names but if the user wishes tohave a specific variable name to be kept hygienic or unhygienic there are two methodsfrom the Context class that allows them explicitly to do that called keep and dirtyrespectively. The keep method adds a variable name from the hygiene list while thedirty method removes it. There are reasons to keep certain variables unhygienic.‘Intended’ variable capture can be used in anaphoric macros where referring to thevariable captured is useful to do some particular task [19, 7].In a language like Python, where the syntax is not explicitly delimited andcontains complex syntactic structures like infix expressions, figuring out how toproperly obtain the correct context can be an issue. Honu [20] and Sweet.js [4] facedthese problems with the approach of enforestation; taking streams of tokens and29converting them into a token tree to obtain structure and properly traverse through it.Pantry approaches this issue by having its macro functions state the expected patternthrough Context class methods in order to properly traverse through them.The Context class contains methods to aid in stating the pattern for the macroto match. In determining the pattern to be obtained by the macro Pantry providesthe user several tools to separate the token stream into sections to be gathered bythe macro function. These tools belong to Pantry’s Context class and are groupedtogether as Pantry’s traversal methods. They include the next method which obtainsthe next token from its current location in the file; the nextLine and the nextBlockmethods, which return sections of tokens and is helpful due to Pythons programstructure being determined by column spacing; and the prev method, which is likethe next method except it takes the token that appears previous to where it is calledand can be used in infix macros. Infix macros are expanded upon in Section 5.3. Allof these traversal methods consumes the token in the file, removing it from the file.The location of where to use the traversal method is kept track by the Context class.As the traversal methods are used, the Context class increments or decrements thelocation in the file. The initial location is always where the macro is found. After thepattern is consumed by the macro function, the location moves to where the nextmacro is found in the file if there are any left.The macro expansion returned by the macro function replaces whatever thetraversal methods have consumed. There are a few cases of when what is replacedmight need to exist not in the location of the macro but just before it. The setupCodemethod allows for the this to happen by appending a text stream to the locationbefore the line the macro is encountered in. It expands the text stream to the sameindentation level as the macro so the macro expansion can be set up to have a tailoredresult from the argument given to this method. These expansions are returned in the30form of strings which Pantry then retokenize and insert into the program.31SECTION 5ExperimentationThis section goes through a few examples of macros written in the Pantry library.These macros further demonstrate the use of the Pantry library as well as explorethe area that macros have in the Python language. These examples utilize PEPs asa resource to determine what type of macros should be implemented. PEPs are avaluable tool to gauge what features the Python community wishes to see in Pythonas well as what future direction Python is headed towards.5.1 Style Standardization MacroIn Python there are sometimes multiple styles to do the same thing. One exampleof this was mentioned in Section 3.3.2, where there are multiple ways to achieve stringinterpolation in Python. Another example of multiple styles is how Python parses linecontinuations. Python’s main style guide mentions that line continuations are impliedwithin parentheses, brackets, or braces so lines can be broken up by wrapping the linewith these characters [21]. Another way to do line continuation, although the guidesays that it is not preferred, is to use a backslash to show that the line continues.x = 5 + 6 + 8 +\\1 + 3 + 5The author of this PEP states that this style of line continuation should be removedfrom Python [22].One goal for Python 3000 should be to simplify the language by removingunnecessary or duplicated features. There are currently several ways toindicate that a logical line is continued on the following physical line.The other continuation methods are easily explained as a logical conse-quence of the semantics they provide; is simply an escape character thatneeds to be memorized.This proposal was rejected for lack of support from the Python developers, so toimplement this style change a macro system like Pantry can be used.321 @star t toker . macro2 def \\( ctx=ctx ) : #Function ’ s name s i g n a l s the macro ’ s name3 nextVar = ctx . next ( )4 cont inuat i on = ctx . nextBlock ( )5 i f nextVar == ’ \\n ’ :6 return ’ ’ ’ (\\n{}) ’ ’ ’ . format ( cont inuat i on ) #Returned temp la te7 else :8 return ’ \\{} ’ . format ( nextVar ) #Template re turned by macroListing 5.1: Pantry’s Backslash MacroPEP 3125 seeks to eliminate Python support for the backslash line continuation. Sothis macro searches through the file and replaces the backslash line continuation withthe standard line continuation contained within parentheses based on the exampleshown in PEP 3125. Pantry recognizes the following function as instructions for amacro through the Python decorator in line 1 of listing 5.1 and it takes the nameof the function as the name of the macro. As seen in line 2 the macro name is ’\\’.Normally in Python syntax this type of character is not allowed in or as the functionname but Pantry bypasses these rules to allow for these forbidden characters to beused in that form. With this name the Pantry library is then able to search throughthe file and replace it with what the user desires. As this test is following PEP3125, the goal is to get replace the ’\\’ continuation making line continuation morestandardized and with less redundant syntax.Backslashes are not only used in line continuations so the stated pattern of themacro must account for only the pattern that it wants to match and replace. As seenin listing 5.1 the macro takes the next token after it finds a ’\\’ and it makes sure thatit is a ’\\’ used in a line continuation (a \\ followed by a newline). If it matches thepattern of being a line continuation it then takes the ’\\’ line continuation and uses33that as part of the return value. If it was not being used as a line continuation thenthe macro expansion returns what the Context object has consumed and that therewill be no change in that part of the file where the ’\\’ was located.1 a s s e r t va l > 4 , \\2 \"Not g r e a t e r than 4\"Listing 5.2: Before Backslash MacroExpansion1 a s s e r t va l >4 , (2 \"Not g r e a t e r than 4\"3 )Listing 5.3: After Backslash MacroExpansionAs can be seen in listings 5.2 and 5.3, the macro takes away the backslash linecontinuation and replaces it with a parentheses enclosure. One thing to notice is thatthe result from the macro does not have column position formatted correctly. This isthe result of using the Python tokenize module, which does not guarantee the samespacing between tokens and is a current limitation of the Pantry library. The spacingdiffers and as such some differences can be seen. Some of the differences in listing 5.3include the string value of the assert statement not being indented or there not beinga space after the greater than symbol. These column spacing differences exist but theresult of the code will always stay the same. We plan to explore solving the columnspacing format issue in future work.So while Python has some redundant syntax, Pantry can be utilized to get rid ofthese features. By utilizing macros the removal of these features can be tested morethoroughly to gauge the impact of the removal, test special cases of what happensif removed, or even transform older versions of Python code to match newer syntaxstructure. This also demonstrates the ability for Pantry to re-add a feature to thelanguage if it becomes deprecated. If this PEP was accepted and the backslashcontinuation is no longer a part of the Python language, this macro would allow forthe legacy code to be supported and compiled. Feature removal is a small subset of34the capabilities of a macro system. A much larger domain of a macro system is theintroduction of new features.5.2 Do-While MacroUnlike other languages such as C or JavaScript, Python does not have a do-whileloop statement. Constructing a macro to introduce such a grammar would be a typicaland valid use case of the Pantry library. The want or need of a do-while statement inPython has been expressed in PEP 315 [23].This PEP proposes adding an optional \"do\" clause to the beginning ofthe while loop to make loop code clearer and reduce errors caused by codeduplication.This PEP, however, has been rejected leaving the hope of a Do-While-statementimplementation to the Pantry library. So this section will discuss enhancing the whileloop in Python based on PEP 315 by adding a \"do\" parameter to clarify while loops.1 x = 02 dowhi le :3 x += 1 #Setup code4 while ( x <= 5) :5 print ( \"{}\" . format ( x ) ) #Loop bodyListing 5.4: Do-While pattern exampleWhen writing a macro for Pantry the pattern must be decided by the user. PEP315 has outlined what a possible do-while statement would look like in Python. Anotable suggestion from PEP 315 include having the setup code be contained withinthe statement so that the entire statement is provided clarity and can be written morenaturally.An example of the pattern can be seen in listing 5.4. In this example, the macrois named dowhile. The reasoning for naming the macro dowhile instead of do is35because of a limitation of the macro being a lexical macro system. The word do isgeneral enough to appear in other lines other than where the macro is intended. Whilethere are methods that exist in Pantry to enable the naming of the macro named do(as can be seen in naming macros with operator characters seen in 5.3), it furthercomplicates the writing of the macro and so I have not included it in this version ofPantry. So this example uses dowhile as the name for the sake of brevity.The setup code is listed within the dowhile block in line 3. The next block, lines4-5, contains the condition statement, x <= 5, and the loop body in lines 5. Thecode, that can vary as the pattern is used, should be captured and kept by the macro.These captured elements includes the setup code, the condition, and the loop bodydiscussed above. The rest of the pattern should provide the information and contextfor the macro to work on so it knows when and where to grab the varying code.1 @star t toker . macro2 def dowhi le ( ctx=ctx ) :3 co lon = ctx . nextLine ( ) #expec ted pa t t e rn o f a co lon and a new l i n e4 doblock = ctx . nextBlock ( ) #Consumes the se tup code o f do b l o c k5 eatWhile = ctx . next ( ) #Expects a wh i l e b l o c k next so consumes ’ wh i l e ’6 cond i t i on= ctx . nextLine ( ) #After wh i l e keyword i s the b l o c k cond i t i on7 loopBody = ctx . nextBlock ( ) #Consumes the loop body o f wh i l e loop8 return \"\"\"{0}9 whi l e True :10 {2}11 {0}12 i f not {1}13 break \"\"\" . format ( doblock , cond i t ion , loopBody )14 #The macro re turns the s t r i n g temp la te to expand the macro wi thListing 5.5: Do-While macro body36To navigate and iterate through the pattern, Pantry uses a collection of traversalmethods belonging to the Pantry Context class. In listing 5.5 the Context class isdenoted as ctx. The dowhile macro uses the various next traversal methods to digestthe pattern so the user can manipulate the expansion that the macro returns. Partof the dowhile macro where the next methods are being used is shown in listing 5.5.Once the dowhile macro is detected the pattern expects a colon so line 3 consumesthe colon. The next part of the pattern is the setup code and the macro expectsthat portion to be in a block so the nextBlock method consumes the next block ofcode. Then the pattern expects a while statement followed by the condition of thedo-while loop. So the while statement is consumed in line 5 and the loop’s conditionstatement is consumed and recorded in line 6. The remaining part of the macro is theloop body and that is recorded by line 7. From this point the macro has broken downthe pattern into its important components and recorded portions of the pattern toallow for manipulation.The dowhile macro then manipulates and returns what the expansion shouldlook like. This return statement replaces the macro from the code body. What isreturned is Python code that Python can interpret and execute as can be seen in lines8-13.371 x = 02 dowhi le :3 x += 14 while ( x <= 5) :5 print ( \"{}\" . format ( x ) )Listing 5.6: Before Do-While MacroExpansion1 x = 02 x +=13 while True :4 print ( \"{}\" . format ( x ) )5 x +=16 i f not ( x <=5 ) :7 breakListing 5.7: After Do-While MacroExpansionThis do-while macro implementation is an example of how Pantry is able to addkeywords to Python programs, in this case the dowhile keyword. The ability to easilyadd personal keywords allows for Python developers to change Python grammar andmanipulate the language to their own style. They can add constructs to provideclarity, organize structure, or even add functionality.385.3 Coalesce Macro1 x = 52 print ( x ?? 2)3 x = None4 x ??= ’Done ’5 print ( x )Listing 5.8: Before Coalesce MacroExpansion1 x =52 i f x ==None :3 tmp__0 =24 else :5 tmp__0 =x6 print (tmp__0 )7 x =None8 i f x ==None :9 tmp__1 =’Done ’10 else :11 tmp__1 =x12 x =tmp__113 print ( x )Listing 5.9: After Coalesce MacroExpansionIn listings 5.8 and 5.9 we see the coalesce macro in action. We have line 2, inlisting 5.8, expand to lines 2-6 in listing 5.9. The introduction of the coalesce operatoralso showcases how Pantry can introduce operators normally not used in Python.Other possible operators, not included in Python, would be the increment, ++, or thedecrement, --, operators that are seen in other languages. Custom features such asthese can be made with Pantry allowing for compact and flexible code.With this macro we see that Pantry can also introduce new operators. Thissection test the introduction of a new operator to Python. The operator is using PEP505 as an inspiration and a template for the coalesce operator, \"??\" [24].The \"None coalescing\" binary operator ?? returns the left hand side ifit evaluates to a value that is not None, or else it evaluates and returnsthe right hand side. A coalescing ??= augmented assignment operator isincluded.39This PEP details an unimplemented operator that is able to have special evaluationrules for the None value in Python. If the left hand side evaluates to None then theright side of the operator will be the result. If the left hand variable is not None thenthe variable value will be the result and right side value will be discarded. If thecoalesce operator is followed by = sign then the left hand variable will be reassignedto the right hand side if it is equal to None.1 @star t toker . macro2 def ??( ctx=ctx ) : #Macro name i s coa l s c e opperator ’?? ’3 previousVar = ctx . prev ( ) #Traverses to prev ious v a r i a b l e4 nextVar = ctx . next ( )5 equa l s = Fal se6 i f nextVar == ’=’ :7 nextVar = ctx . next ( ) #I f i t i s equa l the next w i l l be a va lue8 equa l s = True9 tmpVar = ctx . c l ean ( ’ tmp ’ ) #Makes a hyg i en i c v a r i a b l e ’ tmp ’10 setup = \"\"\" i f {0} == None :11 {2} = {1}12 e l s e :13 {2} = {0}14 \"\"\" . format ( previousVar , nextVar , tmpVar)15 ctx . setupCode ( setup ) #Pantry method to append code on prev ious l i n e1617 i f equa l s : tmpVar = ’ {0} = {1} ’ . format ( previousVar , tmpVar )18 return tmpVarListing 5.10: Coalesce Macro InitiationJust like with the backslash macro in listing 5.1 the name for the coalesce macroconsists of characters normally not allowed in a function name by Python as seen inlisting 5.10 line 2. Pantry provides this bypass to allow for opportunities like creating40a custom operator.In listing 5.10 the way that the information is obtained from around the macrois seen. The prev() traversal method allows for infix macros. The name for infixmacros comes from infix notation and prefix notation. Prefix notation is where theoperand must come before the operators, for example + 1 2, while infix notation theoperator can be between the operands for example 1 + 2. Likewise, an infix macro iswhere the macro can appear after the information it needs to get. Inclusion of infixnotation allows for more stylized grammar control in the Pantry library.Listing 5.10 shows how the captured information of the macro is handled. The ifstatement in lines 5-8 and 17 allow for the coalesce operator to have the form \"??=\"which has the different meaning of assigning the left hand variable to the right handvalue. In line 15 we see a special function of the Pantry context class. The methodsetupCode(..) is for when the expansion of the macro does not want to occur rightwhere the macro is located in the file but just before it. This is for manipulation ofthe code structure and allows for there to be some setup leading up to the macrolocation. Setting up the macro allows for the context of the scope to be kept, whilemanipulating the values in that scope right before the macro is reached. In this casethe set up is making the variable tmp equal to some value before the coalesce macroreturns tmp, making tmp equal to either the left or the right hand side of where thecoalesce operator was located. The variable tmp is also kept hygienized by throughthe Pantry context method clean(..) used in line 9.41SECTION 6ConclusionA look into the creation of a macro system is worthwhile. Languages that aredesigned with macros, like Lisp or C, are difficult to imagine without them. They arean integral part of the language, something that completes and makes the languageeasier to use.Languages without built-in macros, like Python, are typically languages thatare robust with available syntax and structures, making macros not a priority to beimplemented. Even so, Python is an evolving language; it is constantly changing andgrowing as evident by its various version changes and its slew of Python EnhancementProposals. The PEPs show that the Python community has the desire to changevarious aspects of their language. They think that certain features could be improvedif it was done a particular way instead of how it is currently implemented. They thinkthat the introduction of this new feature would greatly benefit the language if includedin the next Python version. Or they think that some old feature of Python no longerhas a place in Python’s modern iteration and should be removed. All of these desiresinfluence the growth of Python. Not all these desires are fulfilled, however, as somePEPs are rejected by the Python developers. So while there exists demand from partsof the community for some particular feature, that feature will never be adopted intothe language. Macros are an alternative way to use that feature. It is independentfrom the development cycle of the Python language. It does not need to wait for thefeature to be approved, developed, and integrated. A macro can simply be writtenand used, rejection be damned.Macros are also able to further refine a new feature or idea. As putting it into usereveals faults in initial design specification as well as openings in which a design can beimproved. The testing of ideas expose possible unique cases through frequent macro42use. It reveals where the newly designed construct should work in a particular wayin a specific situation. It can reveal uses that the new construct does not adequetlycover. An example of this is seen in the backslash continuation operator where whileits removal was wanted the author of the PEP recognized that it still had a place inthe unique case of multi-line strings [22].The predecessors of Pantry revealed various ways that macros can be approached.While the text substitution approach has its own problems it was worth exploringwith Pantry to see how these problems could be amended and improved to gain someof the benefits of syntactic macros.These are still further improvements that can be made to Pantry: ways toimprove the formatting of macros, finding new use cases of different types of macros,and creation of macros that have a different style and declaration format are justsome of the things that can be explored. One particular thing this project wishesto explore in the future is how modular Pantry can become. Pantry was designedto be self-contained within the Python library through the use of standard Pythonmodules like tokenize, but it is worth looking into separating the language and themacro system. After all, the macro system and the language that the expansionis in do not need to be the same; a prime example of this is the C Preprocessor.Aria and Wakita [25] accomplish something similar to this sort of separation with amacro system for JavaScript using Scheme as language that does the macro expansion.The language proposed by Lee et al. [26] also seeks to have a macro system scalethrough multiple languages, having language specific rules handled by that’s language’scompiler/interpreter while the language of the macro system itself only handles only afew certain rules. The creation of a custom parser and lexer with a tool like ANTLRwould be something interesting to look at and expand Pantry with to make the systemscale across multiple languages.43Along with the separation of system and language new issues would arise anddifferent concepts would have to be tackled. One consideration to take note of wouldbe how ASTs or Tokens would be generated not only in consideration of the languagebut also the particular implementation that the language is compiled in. An exampleof this issue being tackled can be found in Liu and Burmako [27] where differentimplementations of Scala produce different separate but valid ASTs. Macros have aunique place in programming languages. Pantry exposes some of the potential thatmacros can have on a language.44LIST OF REFERENCES[1] F. Medeiros, M. Ribeiro, R. Gheyi, S. Apel, C. Kästner, B. Ferreira, L. Carvalho,and B. Fonseca, ‘‘Discipline matters: Refactoring of preprocessor directives inthe# ifdef hell,’’ IEEE Transactions on Software Engineering, vol. 44, no. 5, pp.453--469, 2018.[2] ‘‘The c preprocessor.’’ [Online]. Available: https://gcc.gnu.org/onlinedocs/cpp/[3] ‘‘Macros.’’ [Online]. Available: https://docs.racket-lang.org/guide/macros.html[4] T. Disney, N. Faubion, D. Herman, and C. Flanagan, ‘‘Sweeten your javascript:Hygienic macros for es5,’’ in ACM SIGPLAN Notices, vol. 50, no. 2. ACM,2014, pp. 35--44.[5] Lihaoyi, ‘‘lihaoyi/macropy,’’ Sep 2018. [Online]. Available: https://github.com/lihaoyi/macropy[6] ‘‘Lisp macro.’’ [Online]. Available: http://wiki.c2.com/?LispMacro[7] P. Graham, On Lisp: Advanced Techniques for Common Lisp, ser. An Alan R.Apt book. Prentice Hall, 1994.[8] C.-T. Bindings, M. Flatt, R. Culpepper, D. Darais, and R. B. Findler, ‘‘Macrosthat work together,’’ 2002.[9] M. D. Ernst, G. J. Badros, and D. Notkin, ‘‘An empirical analysis of c preprocessoruse,’’ IEEE Transactions on Software Engineering, vol. 28, no. 12, pp. 1146--1170,2002.[10] F. Medeiros, C. Kästner, M. Ribeiro, S. Nadi, and R. Gheyi, ‘‘The love/haterelationship with the c preprocessor: An interview study,’’ in LIPIcs-LeibnizInternational Proceedings in Informatics, vol. 37. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2015.[11] B. B. Khomtchouk, E. Weitz, P. D. Karp, and C. Wahlestedt, ‘‘How the strengthsof lisp-family languages facilitate building complex and flexible bioinformaticsapplications,’’ Briefings in bioinformatics, vol. 19, no. 3, pp. 537--543, 2016.[12] K. Hamacher, ‘‘Using lisp macro-facilities for transferable statistical tests,’’ inProceedings of the 9th European Lisp Symposium on European Lisp Symposium.European Lisp Scientific Activities Association, 2016, p. 4.[13] P. Seibel, Practical common lisp. Apress, 2006.45[14] ‘‘Pep 343 -- the \"with\" statement.’’ [Online]. Available: https://www.python.org/dev/peps/pep-0343/[15] ‘‘Pep 536 -- final grammar for literal string interpolation.’’ [Online]. Available:https://www.python.org/dev/peps/pep-0536/[16] T. C. Disney, ‘‘Hygienic macros for javascript,’’ Ph.D. dissertation, UC SantaCruz, 2015.[17] E. Visser, ‘‘Meta-programming with concrete object syntax,’’ in InternationalConference on Generative Programming and Component Engineering. Springer,2002, pp. 299--315.[18] M. Flatt, ‘‘Binding as sets of scopes,’’ ACM SIGPLAN Notices, vol. 51, no. 1,pp. 705--717, 2016.[19] D. Hoyte, Let Over Lambda: 50 Years of Lisp. Doug Hoyte/HCSW and Hoytechproduction, 2008.[20] J. Rafkind and M. Flatt, ‘‘Syntactic extension for languages with implicitlydelimited and infix syntax,’’ Ph.D. dissertation, Citeseer, 2013.[21] ‘‘Pep 8 -- style guide for python code.’’ [Online]. Available: https://www.python.org/dev/peps/pep-0008/[22] ‘‘Pep 3125 -- remove backslash continuation.’’ [Online]. Available: https://www.python.org/dev/peps/pep-3125/[23] ‘‘Pep 315 -- enhanced while loop.’’ [Online]. Available: https://www.python.org/dev/peps/pep-0315/[24] ‘‘Pep 505 -- none-aware operators.’’ [Online]. Available: https://www.python.org/dev/peps/pep-0505/[25] H. Arai and K. Wakita, ‘‘An implementation of a hygienic syntactic macro systemfor javascript: a preliminary report,’’ in Workshop on Self-Sustaining Systems.ACM, 2010, pp. 30--40.[26] B. Lee, R. Grimm, M. Hirzel, and K. S. McKinley, ‘‘Marco: Safe, expressivemacros for any language,’’ in European Conference on Object-Oriented Program-ming. Springer, 2012, pp. 589--613.[27] F. Liu and E. Burmako, ‘‘Two approaches to portable macros,’’ École Polytech-nique Fédérale de Lausanne, Tech. Rep., 2017.46",
    "Link": "https://core.ac.uk/download/215414636.pdf"
}