{
    "Title": "A standard-driven communication protocol for disconnected clinics in rural areas",
    "Authors": "Masi, Massimiliano, Pugliese, Rosario, Tiezzi, Francesco",
    "Year": "No year available",
    "Abstract": "The importance of the Electronic Health Record (EHR), which stores all healthcare-related data belonging to a patient, has been recognized in recent years by governments, institutions, and industry. Initiatives like Integrating the Healthcare Enterprise (IHE) have been developed for the definition of standard methodologies for secure and interoperable EHR exchanges among clinics and hospitals. Using the requisites specified by these initiatives, many large-scale projects have been set up to enable healthcare professionals to handle patients' EHRs. Applications deployed in these settings are often considered safety-critical, thus ensuring such security properties as confidentiality, authentication, and authorization is crucial for their success. In this paper, we propose a communication protocol, based on the IHE specifications, for authenticating healthcare professionals and assuring patients' safety in settings where no network connection is available, such as in rural areas of some developing countries. We define a specific threat model, driven by the experience of use cases covered by international projects, and prove that an intruder cannot cause damages to the safety of patients and their data by performing any of the attacks falling within this threat model. To demonstrate the feasibility and effectiveness of our protocol, we have fully implemented it",
    "Keywords": "No keywords available",
    "Publisher": "'Institute of Electrical and Electronics Engineers (IEEE)'",
    "Publication Date": "No publication date available",
    "Journal": "No journal available",
    "Citation Count": 0,
    "Full Text": "A Standard-Driven Communication Protocol for\nDisconnected Clinics in Rural Areas\nMassimiliano Masi, Rosario Pugliese and Francesco Tiezzi\nDipartimento di Sistemi e Informatica, Universita` degli Studi di Firenze\nViale Morgagni, 65 - 50134 Firenze, Italy\nEmails: massimiliano.masi@unifi.it, rosario.pugliese@unifi.it, tiezzi@dsi.unifi.it\nAbstract—The importance of the Electronic Health Record\n(EHR), which stores all healthcare-related data belonging to a\npatient, has been recognized in recent years by governments,\ninstitutions, and industry. Initiatives like Integrating the Health-\ncare Enterprise (IHE) have been developed for the definition\nof standard methodologies for secure and interoperable EHR\nexchanges among clinics and hospitals. Using the requisites\nspecified by these initiatives, many large-scale projects have been\nset up to enable healthcare professionals to handle patients’\nEHRs. Applications deployed in these settings are often con-\nsidered safety-critical, thus ensuring such security properties\nas confidentiality, authentication, and authorization is crucial\nfor their success. In this paper, we propose a communication\nprotocol, based on the IHE specifications, for authenticating\nhealthcare professionals and assuring patients’ safety in settings\nwhere no network connection is available, such as in rural areas\nof some developing countries. We define a specific threat model,\ndriven by the experience of use cases covered by international\nprojects, and prove that an intruder cannot cause damages to the\nsafety of patients and their data by performing any of the attacks\nfalling within this threat model. To demonstrate the feasibility\nand effectiveness of our protocol, we have fully implemented it.\nI. INTRODUCTION\nIn recent years, many eHealth projects have started, with the\naim of providing optimum patient care. Many governments are\nnow switching from a paper-based healthcare management to\nan Electronic Health Record (EHR) based solution. An EHR is\na set of sensitive data written in a machine readable format (i.e.\nHl7’s CDA [1]) containing the healthcare history of a patient,\nincluding, e.g., the patient summary, the prescriptions, and\nthe dispensations of specific medicines. Software components\ndeployed in these settings need to transmit EHRs among\nclinics and hospitals for millions of patients (for example, the\nEU project epSOS [2] potentially serves 500 million patients).\nThese components must protect the healthcare data against\nmalicious attacks. Indeed, tampering or intrusions during the\nexchange of an EHR may have a direct impact on the life of the\npatients. Thus, initiatives like [3] and [1] have been promoted\nfor the development and definition of standard methodologies\nfor the secure and interoperable EHR exchange among clin-\nics and hospitals. Using the requirements specified by these\ninitiatives, many projects have been set up, such as [2], [4],\n[5], [6], [7]. This is not surprising if we also consider that\nthe EU commission has issued a mandate [8] for enforcing\nThis work has been sponsored by the EU project ASCENS, 257414. The\nfirst author has been partially supported by the Company Tiani “Spirit” GmbH.\nthe adoption of EHR systems and the US government has\npublished the Health Insurance Portability and Accountability\nAct (HIPAA) [9] with a similar aim. However using the state-\nof-the-art international standards, as required by most of the\nabove projects has a significant drawback: some proposed\nmethodologies have not been sufficiently analyzed from a\nsecurity point of view (as we show in [10]).\nIn this paper we tackle the problem of sharing patients’\nhealthcare data among clinics without any connection to the\nInternet1. This is a frequent problem in rural areas of devel-\noping countries where no network infrastructure is provided\nby the institutions. Some examples are clinics located in sub-\nSaharan regions (e.g. Malawi, Namibia) or South African\nprovinces (e.g. Limpopo, Mpumalanga) that can be reached\nonly by means of hundreds of kilometers of sand tracks, or\na caravan that travels along townships with first-aid equip-\nment. By relying on the Service Oriented Computing (SOC)\nparadigm, the Integrating the Healthcare Enterprise (IHE) [3]\ninitiative2, promotes standards for the definition of services\nsupporting the exchange of healthcare data and the manage-\nment of patient identifiers. For such a critical scenario, the IHE\nboard proposes the usage of the Cross Enterprise Document\nSharing using Portable Media (XDM) [3]. This specification\nenables the use of different types of electronic support, like\nCDs, DVDs, and USB drivers, for the transmission of EHRs.\nThe documents stored in such a way can then be delivered by\nusing a car-transportation system.\nSpecifically, we focus on authentication of healthcare pro-\nfessionals. User authentication is a basic but crucial task for\nsecurity in general, and healthcare applications in particular.\nIt is required by almost all healthcare projects to enforce\nauthorization of resources (e.g., to prevent unauthorized access\nto specific medicines or patient summaries) based on attributes\nrelated to the professional’s identity (e.g. role and department).\nAs a first contribution of this paper, we propose a protocol\nbased on XDM that guarantees the correct propagation of\nan authentication process performed remotely while ensuring\nsafety properties in the treatment of patients’ healthcare data.\nThen we define a threat model where a hypothetical attacker\n(e.g., [11], [12]) can seriously damage the health of patients\n1The solution to this problem in presence of Internet connection is shown\nin [3] and formally studied in [10].\n2IHE is an initiative by healthcare professionals and industry that strictly\nfollows such international guidelines as HIPAA and EU commission reports.\nDocument \nRepositories\nDocument \nRegistry Document \nConsumer\nDocument \nSource 1\n2\n3\n4\nFig. 1. The XDS workflow\nor obtain unauthorized resources by carrying out different\ntypes of attacks. As a second contribution, we analyze the\nprotocol to prove that, in our threat model, the attacker cannot\nperform any action that can compromise the patients’ safety.\nTo carry out our investigation, we use a general methodology\n(see, e.g., [13]) based on formal methods that have been\nwidely used for the verification of complex computer systems\n(applications to communication protocols are surveyed in, e.g.,\n[14], [15]). In particular, we formally specify the protocol\nusing the process calculus COWS [16] so that the obtained\nmodel contains enough details about the involved technologies\n(this is reflected, e.g., by letting the exchanged messages travel\nalong communication channels with different properties). Then\nwe analyze the obtained model by formulating the protocol’s\nproperties as logic formulae and demonstrating their validity\nthrough the model checker CMC [17].\nIt is worth noticing that our protocol has been expressly\ndesigned with the aim of guaranteeing implementability and\nat the same time avoiding requiring changes in the scenario\nunder consideration that may have an important impact on the\neveryday lives of patients or professionals, since most of the\nprojects are already in a production stage.\nThe rest of the paper is organized as follows. In Section II\nwe provide an account of the scenario with disconnected\nclinics and introduce our protocol for the authentication of\nhealthcare professionals. In Section III we sketch the formal\nspecification of the protocol and present its analysis. Finally,\nin Section IV we touch upon comparisons with related work\nand directions for future work.\nII. A SCENARIO WITH DISCONNECTED CLINICS\nModern healthcare applications rely on the use of inter-\nnational standards for exchanging patients’ healthcare data.\nThe setting which is used the most for exchanging patient\ndocuments within healthcare organizations is based on the IHE\nCross Enterprise Document Sharing (XDS) [3] model depicted\nin Figure 1.\nThe model uses a central document registry that acts as a\ncatalog for the data. The document source (e.g., a medical\ndevice) produces healthcare data for a patient and stores them\nin one or more document repositories (e.g., databases). The\nrepositories extract the metadata from the documents and\nupdate the registry. The document consumer (e.g., a doctor’s\nworkstation) queries the registry and obtains the links to the\nrepositories where the data can be downloaded. In a real\nscenario, dozens of consumers and dozens of sources belong\nto the same registry.\nEach communication in the model is performed by exploit-\ning the SOC paradigm. Each actor (i.e., registry, repository,\nconsumer, source) is a service exchanging SOAP messages\nwith other actors. To provide access control to patients’ data,\nthe human requester must be exactly identified. The IHE\nmodel defines the use of an authentication assertion, encoded\nusing the Security Assertion Markup Language (SAML) [18],\ncontaining the identity of the user sitting behind the client\nactors. A SAML assertion is a signed security token encoded\nusing the XML format issued by a trusted third party service,\nthe Security Token Service (STS)3, that contains statements\nabout an authentication procedure performed by an underlying\nauthentication mechanism (such as Kerberos [19]) for a sub-\nject. The SAML token is then used by the service requester (in\nour case, the document consumer) to interact with the services\nlisted in the assertion. The contacted service provider (in our\ncase, the document registry) uses the assertion to authenticate\nthe requester by verifying the digital signature of the trusted\nissuer.\nWe consider here a healthcare scenario where the clinics\ninvolved need to communicate with hospitals and points of\ncare but network connectivity is missing. This is a common\nscenario for developing countries where the institutions do\nnot provide access to the Internet in all the regions. IHE\naddresses this scenario by defining the XDM integration\nprofile. Basically this profile is an XDS model where some\ncommunications among document consumers, sources, reg-\nistries, and repositories are made by writing data to portable\nmedia (e.g., CDs, DVDs, USB mass storage) and sending them\nthrough a car-transportation system.\nThe outlined scenario presents severe security problems. For\nexample, a patient could forge his own portable media and\ninclude new prescriptions for drugs or an intruder could easily\ngain access to the data by hijacking the carrier on its way (or\nthe carrier itself could act as an intruder).\nIn Section II-A we present our XDM-based communication\nprotocol which is specifically devised for the setting sketched\nabove. Then, in Section II-B we define a threat model4 and\nin Section II-C we explain the need of an extra actor in the\nprotocol to deal with a specific kind of attack considered by\nour threat model. In the next section we will prove that an\nintruder cannot endanger patients by performing any of the\nattacks falling within our threat model.\n3For the sake of simplicity, we assume an STS that is directly able to\nauthenticate users; i.e., it also plays the role of the identity provider.\n4It is worth noticing that the major healthcare initiatives are in the way of\nidentifying some specific threat models (see e.g. [20]). We define our threat\nmodel using their experience as a basis.\nClinic A, \nCreator\nClinic B, \nReceiver\nSTS, \nClinic A\nSTS, \nClinic B\nARR, \nClinic A\nARR, \nClinic B\nSecurity \nOfficer\nTLS\nTLSTLS\nTLS\nVAN\nFig. 2. A typical healthcare scenario with disconnected clinics\nA. The abstract model\nIn the XDS model depicted in Figure 1 (steps 1, 3 and 4) the\nactors are typically required to establish a secure connection\nby means of TLS using the Internet. Since we suppose that no\nInternet connection is available between the consumer/source\nand the registry/repository, we integrate XDS with XDM, a\nprofile specifically devised for dealing with such settings. In\nthis way, the requirement for having strong authentication in\nXDS transactions (i.e., a matching X509 certificate between\nthe TLS handshake and the key inside the token, as in [10])\ncan be relaxed. Indeed, the channel representing the car-\ntransportation system is able to transport only one message\nin only one direction, hence the TLS handshake cannot be\nperformed.\nWe abstract the scenario from a logical point of view as\ndepicted in Figure 2. We identify two systems running an XDS\nsuite: clinic A acting as the creator and clinic B acting as the\nreceiver. The creator runs an instance of a document consumer\nor a document source, while the receiver runs an instance of\na document registry or a document repository. The creator\nqueries or submits documents using the car-transportation\nsystem. Each clinic owns an STS that is responsible for issuing\nand validating SAML tokens. It is worth noting that we make\nexplicit another actor defined by IHE, the ATNA Audit Record\nRepository (ARR), a tamperproof storage that contains the\naudit trails (i.e., log entries) for each transaction performed by\nthe creator/receiver. We suppose that clinics have local clocks,\nbut do not synchronise.\nThe model does not abstract away the kind of commu-\nnication channels used, in order to take into account the\ndifferent guarantees they provide. Hence, we use here three\ndifferent kinds of channels. The first one, denoted by →,\nis a plain TCP/IP channel. The second one, →TLS, is a\nTCP/IP channel where TLSv1 is available. This means that\nthe confidentiality and integrity of TCP packets are guaranteed.\nThe third one,→VAN, represents the car-transportation system\nconveying patients’ healthcare documents. Since this channel\nonly permits sending one message per protocol run, it does\nnot satisfy any mutual authentication properties [21].\n0.\n\nA\u001c STSA : . . . obtains a SAML assertion\nfor B at ts1 with context ctx . . .\nSTSA →TLS ARRA : ts1 , ctx ,A,B\nA\u001c STSA : . . . obtains the\ntoken(K+A , user , {ctx}K+B ) . . .\n1. A→TLS ARRA : ts1 , ctx ,A,B , ts2 , {[K+A , user , ‘doc’]}K−A\n2. A→VAN B : A,B ,msgId1 , ts2 , {[K+A , user , ‘doc’]}K−A ,\ntoken(K+A , user , {ctx}K+B )\n3. B →TLS ARRB : ts2 , ts3 ,A, ctx , {[K+A , user , ‘doc’]}K−A\nTABLE I\nAN ABSTRACT DESCRIPTION OF THE PROPOSED XDM-BASED PROTOCOL\nClinic A, \nCreator STS A ARR A\nClinic B, \nReceiver STS B ARR B\ngetToken\nSAMLToken\nVAN: provideDocuments\n  storeCtx    \nstoreCtx_and_docHash\nvalidate\nlogEvent\nFig. 3. The scenario with disconnected clinics\nThe protocol that we propose, written in a notation com-\nmonly used to describe security protocols, is shown in Table I\nand is graphically depicted in Figure 3. The arrow −→I\nrepresents a normal TCP/IP channel, while •−→I• represents\nthe TCP/IP channel where the communication is protected by\nmeans of a mutual authenticated TLSv1 implementation. The\nnotation {M}K+B stands for the encryption of M using the B’s\npublic key and {[M]}K−A stands for the signature of M using\nA’s private key (where [M] is the hash code of M). Each\nmessage M represents a SOAP 1.2 message strictly defined\nby international standards [1], [3], [22]. ts1 , ts2 and ts3 are\ntimestamps.\nAccording to the XDM specification, the creator starts\nby obtaining a token through its local STS . In our setting\nthe token, which for the sake of readability is denoted by\ntoken(K+A , user , {ctx}K+B ), is a SAML assertion. This nota-\ntion stands for the signed tuple\n{[K+A ,STSname, samlTs, user ,B , {ctx}K+B ]}K−STSA\ncontaining the name user of the user that is performing the\naction and where it comes from (indicated by A’s public key),\nthe name STSName of the issuer, the timestamp samlTs of\nthe assertion, the receiver B where the assertion can be used,\nand the encrypted context. Notably, a token permits only one\noperation via the portable media. The token issuance process is\nassumed to be performed according to [10] and is not detailed\nhere for the sake of simplicity (for this reason, it is indicated\nas step 0 in the protocol). It is, however, worth noticing that\na one-to-one correspondence exists between the token issued\nduring the process and the WS-Trust [23] context ctx, that\nis a unique identifier computed by the STS . The issuance\nprocess is also recorded in ARRA by storing the quadruple\nts1 , ctx ,A,B . This quadruple records that a token was issued\nwith context ctx at timestamp ts1 for a message sent from A\nto B . We assume that this message is sent over →TLS .\nIn message 1, clinic A updates the log in ARRA by adding a\nnew timestamp ts2 , representing the instant when the portable\nmedium is created (e.g. the CD is burned), and a signed tuple,\nrepresenting the username of the physical person sitting in\nfront of the workstation, which is the same as the subject of the\nSAML assertion, and the document, here abstracted as ‘doc’.\nNotably, we are not deviating from the standards. In fact,\nthe username value is part of the metadata accompanying the\ndocument itself; the interested reader is referred to the XDS.b\ndocumentation (XCN values, [3]) for the other metadata.\nIn message 2, clinic A sends the portable medium through\nthe car-transportation system that travels to B. The message\ncontains a unique identifier, msgId1, the signed document and\nthe SAML token.\nWhen clinic B receives the message, it checks if the\nvalue user equals the subject of the assertion and if the\nkey contained in the signed document matches the holder-\nof-key data inside the token. If both tests succeed, clinic\nB validates the assertion to its STSB through message 3,,\nas in [10], and writes in its local ARRB the following\nknowledge: “someone, probably A, at time ts2 , sent a message\nwith identifier ctx for a document represented by the signed\ntuple {[K+A , user, ‘doc’]}K−A ; now is ts3 ”. The document also\ncontains the certificate that corresponds to the signer’s public\nkey.\nB. The threat model\nBy taking the features of the different kinds of communica-\ntion channels into account, we consider a standard intruder a`\nla Dolev-Yao acting only along channel →VAN . The intruder\ncan see all the messages passing through the channel (i.e.,\nhe can read the documents delivered via van), he or she is a\nlegitimate user of the network (in our setting this means that\nhe or she is able to sign documents) and has the opportunity\nto be a receiver for any user. We also assume that encryption\nand hashing functions cannot be broken.\nOur assumption that channels of type→TLS are not subject\nto the intruder is supported by the fact that, in the real world,\neach clinics’ information system usually runs on a single\nand audited, machine. Therefore the problem of intercepting\nmessages can be solved better by using intrusion detection\ntechniques.\nWe thus identify four different types of attacks the intruder\nI can perform:\n1) I suppresses a message. For instance, I could suppress\na submission for a new rare form of allergy or a\nquery for crucial healthcare data and, in both cases,\nthe suppression may lead to the death of the patient\nif the patient travels among clinics. It is thus crucial\nfor patients’ safety to consider suppressed messages as\nattacks, as these messages could bear data necessary for\nthe patients’ lives. Moreover, since messages traveling\nalong →VAN may have unbounded delays, to stay on\nthe safe side, we also consider these delayed messages\nto be attacks. To appropriately deal with these attacks\nwe introduce a new actor, called Security Officer (see\nFigure 2) in the scenario. This actor’s role will be\ndetailed in the next section.\n2) I acts as a healthcare professional sitting at A wanting to\naccess restricted resources by reusing a previously issued\nSAML token. For instance, suppose that nurse (a valid\nuser at A) wants to obtain a large amount of drugs for\nthe illegal market. He or she could reuse an assertion,\nwhich was issued for another purpose and has already\nbeen used to create a new illicit prescription. nurse then\nsteals the assertion from the portable medium, attaches\nit to his or her new prescription and sends:\nA→VAN B : A,B,msgId , ts2 ,\n{[K+A ,nurse, ‘prescr ’]}K−A ,\ntoken(K+A , user, {ctx}K+B )\n(1)\nThis attack is discovered by the Receiver because the\nuser of the token is different from the creating user\nembedded in the document.\n3) I obtains the message by listening on→VAN , suppresses\nit, and sends:\nI →VAN B : I,B,msgId , ts2 ,\n{[K+A , user , ‘prescr ’]}K−I ,\ntoken(K+A , user, {ctx}K+B )\n(2)\nThe difference between this attack and attack number 2\nis that there nurse is sitting at clinic A, while here the\nintruder is intercepting the van. This attack is discovered\nby the Receiver because the public part of the intruder’s\nsigning key K−I is different from the key associated with\nthe document and inside the token.\n4) I sends the same (intercepted) message multiple times,\nfor example to obtain the same resource multiple times.\nThis attack is similar to attacks 2 and 3, and is a\nform of replay attack. It is discovered by the Receiver\nbecause multiple ctx are present in the database (only\nthe message which is received first is left).\nC. The role of the officer\nLet us now suppose there are several clinics A1, . . . , An,\nsuch that each Ai has its own ARRi and acts as a creator\nfor the clinic B. The officer polls the clinics in a round-robin\nfashion to detect if attack 1 has been performed, in which case\nhe or she establishes which actions must be performed by the\nclinics as countermeasures. To this aim, every quantum of time\nt the officer checks the logs of every ARRi by appropriately\ncomparing them with the logs stored in the clinic B.\nWhen the officer visits clinic Ai, he or she obtains the\nset Alogi of all the audit trails from his or her last visit.\nLet mi be the maximum among the timestamps of the au-\ndits (the officer saves the previous value of mi as oldmi).\nWhen the officer visits clinic B, he or she obtains the\nset Blog of all the audits trails. Let’s recall what an audit\nlocated in ARRB looks like. It can be defined as a tuple\na = 〈creation ts, arrival ts, sender , ctx ,Signature〉, where\ncreation ts is the creation time at sender , arrival ts is the\narrival time at B, ctx is the context, and Signature is the\nsignature of the document. We use a(1) to denote creation ts\nand a(3) to denote sender . The officer can then partition Blog\nby defining:\nBlog |Ai,mi =\n{\na | a(3) = Ai ∧ oldmi < a(1) ≤ mi\n}\nEach element Blog |Ai,mi of the partition contains the audits\ncoming from clinic Ai with a timestamp greater than the old\nreading oldmi taken by the officer and not greater than the\nlast timestamp mi read at Ai.\nThe officer can now tell the different situations apart. If\nAlogi = Blog |Ai,mi then all messages produced at clinic\nAi arrived safely at clinic B. If this holds for all clinics,\nthen we have\n⋃n\ni=1Alogi = Blog which means that every\nmessage from any clinics has safely arrived at B. If instead\nAlogi \\(Blog |Ai,mi) 6= ∅ then there are messages in Ai that\nhave not yet arrived at B. The messages are suppressed\nor are late (attack 1). In the opposite situation, i.e., when\nBlog |Ai,mi\\Alogi 6= ∅, then there are more messages at B\nthan those produced by the clinics, thus some messages have\nbeen introduced into the channels by the intruder (attacks 2,\n3 and 4).\nIII. SPECIFICATION AND ANALYSIS\nOur formal analysis is based on the use of the process cal-\nculus COWS [16] to specify the protocol and the transactions\ninvolved, while reflecting many real-world implementation\ndetails (e.g. algorithms, field names and message exchanges\nare taken from OASIS standards). Due to their rich repertoire\nof elegant meta-theories, proof techniques and analytical tools,\nprocess calculi currently play a central role in laying rigorous\nmethodological foundations for specification and validation of\nSOC applications. Our preference for COWS is motivated\nby its mechanisms and primitives that have proven to be\nparticularly expressive for modeling the behavior of service-\noriented applications (see, e.g., [24], [25]). Moreover, the\ncalculus is equipped with tools for formulating properties of\nCOWS specifications and demonstrating their validity, like the\ntemporal logic SocL and its model checker CMC [17] that\nwe use in our investigation. In fact, process calculi together\nwith modal and temporal logic, possibly supported by efficient\nsoftware tools, have long been proved suitable to reason about\nthe design of complex computing systems (see, e.g., [26], [27],\n[28]).\nFor the sake of simplicity, we present here just a sketch of\nthe COWS specification of the protocol. We refer the inter-\nested reader to [29] for a complete account of the specification,\nand to [16], [25] for the presentation of COWS and of many\nexamples illustrating its peculiarities and expressiveness.\nThe COWS term representing the overall scenario is\nlet . . . in\n[hashReq]] [hashResp]] . . .\n( Sha(hashReq,hashResp)\n| Cipher(. . .)\n| Signer(. . .)\n| ClinicA(hashReq,hashResp,. . .)\n| ClinicB(hashReq,hashResp,. . .)\n| Officer(. . .) )\n| . . . intruders . . .\nend\nwhere to make the reading easier, we have omitted irrelevant\ndetails. The protocol has three main participants, ClinicA,\nClinicB and Officer. They are composed by using the\nparallel composition operator | that allows them to be\nconcurrently executed and to interact with each other. Since\nCOWS does not offer primitives for, e.g., encryption and\nhashing, these and other useful security-related features are\nprovided to each participant through a library of functions,\nimplemented as a set of shared services. We have implemen-\ntations of such algorithms as SHA for hashing (Sha), RSA\nfor public-key cryptography (Cipher), and digital signatures\n(Signer), that are necessary to properly manage the data to\nbe exchanged during protocol runs. These COWS services\nplay a role similar to that of functions in the applied pi-\ncalculus [13]. The delimitation operator [ ] is used here\nto restrict access to services Sha, Cipher, and Signer\nby declaring that hashReq, hashResp, . . . are private\noperation names known only to the three participants (other\nthan, of course, the services that provide them). As usual,\nthe let construct permits the definition of specifications in a\nmodular style.\nWithin the above let construct, the COWS service defini-\ntion of the creator clinic is:\nClinicA(hashReq,hashResp,. . .) =\n[clockA#][write#][getToken#] . . .\n( Clock(clockA,. . .) | ARR(write,. . .) | STS(getToken,,. . .)\n| Creator(clockA,write,getToken,. . .) )\nThe term ClinicB representing the receiving clinic is similar\nto ClinicA, but for the term Receiver in place of Creator.\nEach clinic has its own local Clock, ARR and STS, with which\nit shares private partner and operation names (e.g., clockA,\nwrite and getToken). These names permit defining private\nendpoints to simulate internal interaction with Clock, secure\nconnections with ARR along channels of the type →TLS , and\nauthenticated connections with the STS along channels of the\ntype → (as dealt with in [10]). The local clock ticks along\na private endpoint and, when prompted, returns the current\nvalue to the requester. If the STS receives a request from the\nassociated participant instead, then it generates and returns\na SAML token containing a unique context. Finally, ARR\ninstantiates a stack, i.e., a LIFO data structure used to store\naudit trails, and provides different functionalities depending\non the role of the participant. In the case of a creator role,\nARR waits the first message from the STS stating that an audit\ntrail with a given context will arrive from the clinic. When\nthe audit is received, it is pushed onto the stack. In the case\nof a receiver role, ARR simply pushes the received audit trail\nonto the stack, unless the audit trail contains a context already\nstored (attack 4).\nThe security Officer is in charge of revealing attack 1,\nwhich occurs when the intruder suppresses messages. Only\none instance of Officer can run at a given time (in order\nto reduce the model state space). Once activated, Officer\nfirst gets the values stored by Creator’s ARR and saves the\nmaximum timestamp of the audits in the Creator’s stack in a\nvariable MaxT1. Then, Officer gets the audits, which have\ntimestamp not greater than MaxT1, stored by Receiver’s\nARR. After collecting the audits from the two repositories,\nOfficer compares them to detect an attack 1, as defined in\nSection II-C.\nEach of the four attacks described in Section II-B is modeled\nas a COWS term running in parallel with the protocol’s partic-\nipants. As expected, the intruder can freely suppress/forge/read\nmessages along the →VAN channel. Each attack is revealed\nby evaluating a SocL formula that exploits actions signaling\nthat specific data tuples are sent along some given endpoints.\nFor instance, the COWS term modeling the intruder con-\nducting attack 1 is\n[A][MsgId1][Ts2][SignedDoc] . . .\nb.van?<A,b,MsgId1,Ts2,SignedDoc,. . .>.\n(sys.attack1!<messageSuppressed,SignedDoc>\n| sys.attack1?<messageSuppressed,SignedDoc>.\nofficer.activate!<> )\nThe intruder starts with a receive activity of the form\nb.van? < A, b, MsgId1, Ts2,SignedDoc, . . . > corresponding\nto the reception of a message for B over the channel\n→VAN (here rendered as the public endpoint b.van).\nThe receive activity initializes the variables A, MsgId1,\nTs2, SignedDoc,. . . , declared local to the term by the\ndelimitation operator, with the message data. When the\nintruder intercepts a message, communication along the\nendpoint sys.attack1 takes place (i.e., the invoke activity\nsys.attack1! < messageSuppressed, SignedDoc > and\nthe receive activity sys.attack1? < messageSuppressed,\nSignedDoc > synchronise); this is used during the analysis\nto signal that the system is under attack. Only at this\npoint Officer is activated (by means of a signal over\nofficer.activate), after which it can go to clinic A and B\nat any time.\nThe analysis of the protocol is carried out by exploiting the\nsoftware tool CMC for model checking SocL formulae over\nCOWS specifications. SocL [17] is an action- and state-based,\nbranching time, temporal logic specifically designed to express\nproperties of service-oriented systems. We will not present all\nthe constructs of SocL (we refer the interested reader to [17]\nfor a detailed presentation of the logic and its applications),\nbut only explain the formula used to reveal an attack 1:\nAG [attack1Performed(message,$doc)]\nAF {attack1DetectedByOfficer(message,%doc)} true\nThe formula means that it holds globally (AG), i.e., in any state\nof the model, that if (operator [. . .]5) an attack of type 1 is\nperformed by the intruder, then always (AF) this attack will be\ndetected by Officer.\nThe previous formula is stated in terms of abstract actions,\nmeaning that, e.g., an attack of type 1 has been performed,\nwhile the COWS specification is stated in terms of concrete\nactions, i.e. communication of data tuples along endpoints.\nTo verify an abstract property over a concrete specification,\nCMC permits specification of a set of abstraction rules. For\nexample, rule\nAction sys.attack1<messageSuppressed,$signedDoc>\n-> attack1Performed(message,$signedDoc)\nmaps the concrete action corresponding to a communica-\ntion along sys.attack1 to the abstract action attack1-\nPerformed. A similar rule is used for mapping a communi-\ncation along sys.attack1Detected, performed by Officer\nwhen it discovers that a message has been suppressed, to the\nabstract action attack1DetectedByOfficer. Evaluation of\nthe above formula returns TRUE, which means that if a message\ncontaining a certain document is suppressed, then the officer\nwill discover that B did not receive that specific message.\nThe use of abstraction rules to relate concrete actions of\nspecifications with abstract actions of formulae is a peculiarity\nof CMC and of the verification methodology it enables. This\npermits one to initially formalize the desired properties as\nSocL formulae in a way that is independent from individual\nspecifications and then to verify them by tailoring the specifi-\ncation under analysis by means of proper abstraction rules.\nThe remaining attacks are detected by following a similar\napproach; for each attack we demonstrate that the intruder\ncannot successfully perform it. We refer the interested reader\nto [29] for the complete description of the analysis.\nIV. CONCLUSIONS\nWe have presented a feasible and effective communication\nprotocol, based on international standards, for exchanging\npatient healthcare information among disconnected clinics and\nhospitals, while preserving the security of healthcare data and\nthe safety of patients.\nWe have considered the IHE standards based on the XDS\nfamily [3] for authenticating healthcare professionals in trans-\nactions related to exchange of patients’ data. In particular, to\ndeal with a scenario where clinics do not have an Internet\nconnection and exchange data by using a car-transportation\nsystem, we rely on the IHE XDM integration profile. We\ndefined a specific threat model driven by the experience of use\ncases covered by international projects. Then we formalized\nour protocol using the process calculus COWS and analyzed\nit through the model checker CMC to prove that it is robust\nenough to hold out against the attacks described in Section II.\nIt is worth noting that our protocol is password-based in\norder to comply with the standard WS-Security Username\n5This is the modal logic operator box: [a]f states that, no matter how a\nprocess performs action a, the state it reaches in doing so will necessarily\nsatisfy the property expressed by f.\nToken Profile. Therefore, the protocol is secure as long as\nthe passwords are kept secured.\nSince our reference standards are well-understood and\nimplemented, we set ourselves the goal of only suggesting\nchanges that can be easily implemented by vendors. In-\ndeed, we have implemented the protocol using WS-Trust 1.3,\nSAML 2.0, WS-Security and WS-Security Username Token\nProfile 1.1. We have also used the Axis2 libraries6 and the\nJBoss application server7. Our Java implementation consists\nof four services: a Document Consumer, a Document Registry,\na Document Repository and a Security Token Service8. More-\nover, according to the XDM standard, an application capable\nof writing messages in the portable media is exploited. All\nthe XDS and XDM services are given as a courtesy of the\ncompany Tiani “Spirit” GmbH9, located in Vienna, Austria.\nAn outline of the overall implementation of the protocol is\navailable online [29].\nA. Related work\nAnalysis of security protocols using formal methods is\nnot a novel research field (see, e.g., [14] and [15] for a\nsurvey). For what concerns analysis of web services, Microsoft\nResearch proposes the specification languages TulaFale [30],\n[31] and TLA+ [32]. TulaFale uses the model checking engine\nCryptoVerif [33] and only considers SOAP message rewrite\nattacks. Instead, our threat model covers other kinds of attacks\nwhose relevance in healthcare scenarios emerges from the\nexperience gained from international projects. We leave the\nstudy of the interplay between rewrite attacks and the use of\nthe SAML specification for future investigation, since, to the\nbest of our knowledge, any SAML-based protocol could be\nsubject to rewrite attacks. In [30] the authors analyze WS-\nTrust for a secure exchange of a Security Context Token while\nwe consider WS-Trust for issuing a SAML token. TLA+ is\na language based on the Temporal Logic of Actions whose\nspecifications can be analysed by using the model checker\nTLC [34]. In [35] the authors analyze the Web Services\nAtomic Transaction protocol, which however is a protocol\nfor distributed transactions among web services rather than\na security protocol.\nThe Casper tool [36] gives the possibility to define proper-\nties of the communication channel. However, Casper’s main\nfocus is in proving the hierarchy of Lowe’s authentication\nproperties [21] which do not hold in the case of our channel\nrepresenting the car-transportation system.\nThe SAML 1.0 and 2.0 specifications have been studied\nin e.g. [37], [38], [39]. However, these works concentrate\non the SAML Protocol and Profiles [40] to obtain SAML\nAuthentication assertions, while we focus on WS-Trust. The\nwork closest to ours is [37] where the SAML-based Single\nSign-On for Google Apps is analyzed with the tool AVISPA\n6Available at http://ws.apache.org/axis2.\n7Available at http://www.jboss.org.\n8Available as Axis2 service at http://178.188.229.34:41081/\nSpiritIdentityProvider/services/STS09?wsdl.\n9Web site: http://www.tiani-spirit.com\n[41]. A flaw in the Google implementation is found, where a\nfake service provider can potentially access a Google resource\nwithout knowing the password of the user. The flaw discovered\nis in the format of the SAML assertion, which lacks the\nAudience list. In our scenario, however, this kind of attack\ncannot occur since the Audience list must be contained in\nthe assertion and refer to the registry.\nB. Future work\nAs the previously mentioned related work and ours witness,\ndesigning communication protocols that simply adhere to IHE\nspecifications does not guarantee the absence of security flaws.\nDue to the widespread diffusion of such standards, especially\nfor managing EHRs, it is thus worthwhile to pursue our formal\nmethods-based investigation of the security issues that can\narise in healthcare environments. An issue that needs to be\nconsidered is mobility of healthcare professionals among clin-\nics and hospitals. In fact, differently from patients, healthcare\nprofessionals need to authenticate themselves, possibly on\ndifferent clinics. Since IHE does not provide any standard\nfor regulating such mobility, to guarantee the coherence of\nARR’s audit trails some commonly used solutions can be\nexploited, ranging from using different accounts for the same\nprofessional to adopting a synchronized directory structure.\nHowever, due to the lack of Internet connectivity in our set-\nting, feasibility of these solutions needs further investigation.\nMoreover, we plan in the near future to study the application\nof the least-privilege concept to the automated enforcement of\nXACML-based access control policies.\nREFERENCES\n[1] Health Level Seven organization, “Hl7 standards,” 2009, http://www.hl7.\norg.\n[2] The epSOS project, “An European eHealth Project,” 2010, http://www.\nepsos.eu.\n[3] The IHE Initiative, “IT Infrastructure Technical Framework,” 2009, http:\n//www.ihe.net.\n[4] The Nationwide Health Information Network (NHIN), “An American\neHealth Project,” 2009, http://healthit.hhs.gov/portal/server.pt.\n[5] GIP DMP, “Dossier Me´dical Personnel,” 2009, http://www.d-m-p.org.\n[6] ARGE-ELGA, “Die o¨sterreich elektronische gesundheitsakte,” 2008,\nhttp://www.arge-elga.at.\n[7] The South African Department of Health, “EHR project in\nSouth Africa,” 2009, http://southafrica.usembassy.gov/root/pdfs/\npepfar-hmis-docs/ndoh-e-hr-for-south-africa.pdf.\n[8] EU Commission, “M/403 EN: Standardisation mandate addressed\nto CEN, CENELEC and ETSI in the field of Information\nand Communication Technologies,” European Commission\nEnterprise And Industry Directorate-General, Tech. Rep., 2007,\nhttp://ec.europa.eu/enterprise/standards policy/mandates/database/\nindex.cfm?fuseaction=search.detail&id=363#.\n[9] US Congress, “Health Insurance Portability and Accountability\nAct,” Department of Health, Tech. Rep., 1996, http://www.cms.gov/\nHIPAAGenInfo/.\n[10] M. Masi, R. Pugliese, and F. Tiezzi, “On Secure Implementation of an\nIHE XUA-Based Protocol for Authenticating Healthcare Professionals,”\nin ICISS, ser. LNCS, vol. 5905. Springer, 2009, pp. 55–70.\n[11] D. Dolev and A. Yao, “On the security of public key protocols,” IEEE\nTransactions on Information Theory, vol. 29, no. 2, pp. 198–207, 1983.\n[12] P. Broadfoot and G. Lowe, “On Distributed Security Transactions that\nUse Secure Transport Protocols,” in CSFW. IEEE Computer Society,\n2003, p. 141.\n[13] M. Abadi and C. Fournet, “Mobile values, new names, and secure\ncommunication,” in POPL. ACM, 2001, pp. 104–115.\n[14] L. Ma and J. Tsai, “Formal verification techniques for computer com-\nmunication security protocols,” Handbook of Software Engineering and\nKnowledge Engineering, vol. 1, pp. 23–46, 2001.\n[15] C. Fidge, “A Survey of Verification Techniques for Security Protocols,”\nSoftware Verification Research Centre, The University of Queensland,\nTech. Rep. 01-22, 2001.\n[16] A. Lapadula, R. Pugliese, and F. Tiezzi, “A Calculus for Orchestration\nof Web Services.” in ESOP, ser. LNCS, vol. 4421. Springer, 2007, pp.\n33–47.\n[17] A. Fantechi, S. Gnesi, A. Lapadula, F. Mazzanti, R. Pugliese, and\nF. Tiezzi, “A model checking approach for verifying COWS specifi-\ncations,” in FASE, ser. LNCS, vol. 4961. Springer, 2008, pp. 230–245.\n[18] OASIS Security Services TC, “Assertions and protocols for the OASIS\nsecurity assertion markup language (SAML) v2.02,” 2005, http://docs.\noasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.\n[19] B. Neuman and T. Ts’o, “Kerberos: An authentication service for\ncomputer networks,” IEEE Communications Magazine, vol. 32, no. 9,\npp. 33–38, 1994.\n[20] The Nationwide Health Information Network (NHIN), “Threat models,”\n2009, http://wiki.directproject.org/Threat+Models.\n[21] G. Lowe, “A Hierarchy of Authentication Specifications,” in CSFW.\nIEEE Computer Society, 1997, pp. 31–44.\n[22] W3C, “World Wide Web Consortium,” http://www.w3.org.\n[23] OASIS Web Services Security TC, “WS-Trust 1.3,” 2007, http://docs.\noasis-open.org/ws-sx/ws-trust/200512/ws-trust-1.3-os.pdf.\n[24] A. Lapadula, R. Pugliese, and F. Tiezzi, “Specifying and Analysing\nSOC Applications with COWS,” in Concurrency, Graphs and Models,\nser. LNCS, vol. 5065. Springer, 2008, pp. 701–720.\n[25] F. Tiezzi, “Specification and Analysis of Service-Oriented Applications,”\nPhD Thesis in Computer Science, Dipartimento di Sistemi e Informatica,\nUniversita` degli Studi di Firenze, 2009, http://rap.dsi.unifi.it/cows/theses/\ntiezzi phdthesis.pdf.\n[26] E. M. Clarke, O. Grumberg, and D. Peled, Model Checking. MIT Press,\n1999.\n[27] J. Bradfield and C. Stirling, “Modal logics and mu-calculi: an introduc-\ntion,” Handbook of Process Algebra, pp. 293–330, 2001.\n[28] O. Grumberg and H. Veith, Eds., 25 Years of Model Checking - History,\nAchievements, Perspectives, ser. LNCS, vol. 5000. Springer, 2008.\n[29] M. Masi, R. Pugliese, and F. Tiezzi, “Security analysis of standards-\ndriven communication protocols for healthcare scenarios,” Universita`\ndegli Studi di Firenze, Dipartimento di Sistemi e Informatica, Tech.\nRep., 2010, http://rap.dsi.unifi.it/cows/papers/xds-xdm.pdf.\n[30] K. Bhargavan, R. Corin, C. Fournet, and A. Gordon, “Secure sessions\nfor web services,” in SWS. ACM, 2004, pp. 56–66.\n[31] K. Bhargavan, C. Fournet, A. Gordon, and R. Pucella, “TulaFale: A\nSecurity Tool for Web Services,” in FMCO, ser. LNCS, vol. 3188.\nSpringer, 2004, pp. 197–222.\n[32] L. Lamport, Specifying Systems, The TLA+ Language and Tools for\nHardware and Software Engineers. Addison-Wesley, 2002.\n[33] B. Blanchet, “CryptoVerif: Computationally Sound Mechanized Prover\nfor Cryptographic Protocols,” Dagstuhl seminar “Formal Protocol Veri-\nfication Applied”, 2007.\n[34] L. Lamport and Y. Yu, “TLC – The TLA+ Model Checker,” 2003, http:\n//research.microsoft.com/en-us/um/people/lamport/tla/tlc.html.\n[35] J. Johnson, D. Langworthy, L. Lamport, and F. Vogt, “Formal specifi-\ncation of a web services protocol,” J. Log. Algebr. Program., vol. 70,\nno. 1, pp. 34–52, 2007.\n[36] G. Lowe, “Casper: A Compiler for the Analysis of Security Protocols,”\nJournal of Computer Security, vol. 6, no. 1-2, pp. 53–84, 1998.\n[37] A. Armando et al, “Formal Analysis of SAML 2.0 Web Browser Single\nSign-On: Breaking the SAML-based Single Sign-On for Google Apps,”\nin FMSE. ACM, 2008, pp. 1–10.\n[38] T. Groß, “Security analysis of the saml single sign-on browser/artifact\nprofile,” in ACSAC. IEEE Computer Society, 2003, pp. 298–307.\n[39] S. Hansen, J. Skriver, and H. Nielson, “Using static analysis to validate\nthe SAML single sign-on protocol,” in WITS. ACM, 2005, pp. 27–40.\n[40] OASIS Security Services TC, “Profiles for the OASIS Security Assertion\nMarkup Language (SAML) V2.0,” 2005, http://docs.oasis-open.org/\nsecurity/saml/v2.0/saml-profiles-2.0-os.pdf.\n[41] A. Armando et al, “The AVISPA Tool for the Automated Validation of\nInternet Security Protocols and Applications,” in CAV, ser. LNCS, vol.\n3576. Springer, 2005, pp. 281–285.\nLIST OF ACRONYMS\nARR: Audit Record Repository\nATNA: Audit Trail and Node Authentication\nAVISPA: Automated Validation of Internet Security\nProtocols and Applications\nCDA: Clinical Document Architecture\nCMC: COWS model checker\nCOWS: Calculus for Orchestration of Web Services\nEHR: Electronic Health Record\nepSOS: European Patients Smart Open Services\nHIPAA: Health Insurance Portability and\nAccountability Act\nHl7: Health Level Seven International\nIHE: Integrating the Healthcare Enterprise\nIP: Internet Protocol\nLIFO: Last In First Out\nOASIS: Organization for the Advancement of\nStructured Information Standards\nSAML: Security Assertion Markup Language\nSHA: Secure Hash Algorithm\nSOAP: Simple Object Access Protocol\nSOC: Service-Oriented Computing\nSocL: Service-Oriented Computing Logic\nSTS: Security Token Service\nTCP: Transmission Control Protocol\nTLA+: Temporal Logic of Actions specification\nlanguage\nTLC: TLA+ model Checker\nTLS: Transport Layer Security\nW3C: World Wide Web Consortium\nXACML: eXtensible Access Control Markup Language\nXCN: eXtended Composite ID Number and name\nfor persons\nXDM: Cross Enterprise Document Sharing using\nPortable Media\nXDS: Cross Enterprise Document Sharing\nXML: eXtensible Markup Language\n",
    "Link": "https://core.ac.uk/download/12097349.pdf"
}